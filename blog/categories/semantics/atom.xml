<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Semantics | Mark Chang's Blog]]></title>
  <link href="http://ckmarkoh.github.io/blog/categories/semantics/atom.xml" rel="self"/>
  <link href="http://ckmarkoh.github.io/"/>
  <updated>2017-05-12T23:47:33+08:00</updated>
  <id>http://ckmarkoh.github.io/</id>
  <author>
    <name><![CDATA[Mark Chang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vector Space of Semantics]]></title>
    <link href="http://ckmarkoh.github.io/blog/2016/07/10/nlp-vector-space-semantics/"/>
    <updated>2016-07-10T14:06:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2016/07/10/nlp-vector-space-semantics</id>
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>如果要判斷某個字的語意，可以用它鄰近的字來判斷，例如以下句子：</p>

<blockquote>
  <p>The dog run.
A cat run.
A dog sleep.
The cat sleep.
A dog bark.
The cat meows.
The bird fly.
A bird sleep.</p>
</blockquote>

<p>由於 <em>dog</em> 和 <em>cat</em> 這兩個字出現在類似的上下文情境中，因此，可以判斷出 <em>dog</em> 和 <em>cat</em> 語意相近。</p>

<p>如果要能夠用數學運算，來計算語意相近程度，可以把文字的語意用向量表示，如下：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{array}{c|c c c c c c c c c }

     &a &bark &bird &cat &dog &fly &meow & run & sleep & the \\ \hline

 dog &2 &1 &0 &0 &0 &0 &0 &1 &1 &1 \\

 cat &1 &0 &0 &0 &0 &0 &1 &1 &1 &2 \\

 bird &1 &0 &0 &0 &0 &1 &0 &0 &1 &1 

\end{array}

 %]]&gt;</script>

<p>其中， <em>dog</em> 的向量為  ( 2, 1, 0, 0, 0, 0, 0, 1, 1, 1 ) ，第一個維度表示 <em>dog</em> 在 <em>a</em> 旁邊的次數有 2 次，第二個維度表示在 <em>bark</em> 旁邊的次數有 1 次，以此類推。</p>

<!--more-->

<h2 id="vector-space-of-semantics">Vector Space of Semantics</h2>

<p>有了向量就可以用 <em>cosine similarity</em> 來計算語意相近程度。</p>

<p>給定兩向量 <script type="math/tex">A = (a_1,a_2,...,a_n)</script> 和<script type="math/tex">B = (b_1,b_2,...,b_n)</script> ，則這兩向量的 <em>cosine similarity</em> 為：</p>

<script type="math/tex; mode=display">

\frac{A \cdot B}{|A||B|}=  \frac{\sum a_i b_i}{\sqrt{\sum_i a_i^2}\sqrt{\sum_i b_i^2}}

</script>

<p><em>cosine similarity</em> 算出來的值，即是計算 <script type="math/tex">A</script> 和 <script type="math/tex">B</script> 兩向量的夾角的 <em>cosine</em> 值。 <em>cosine</em> 值越接近 1 ，表示兩向量夾角越小，表示兩向量的語意越接近。</p>

<p>根據以上例子， <em>dog</em> ( 2, 1, 0, 0, 0, 0, 0, 1, 1, 1 ) 和 <em>cat</em> ( 1, 0, 0, 0, 0, 0, 1, 1, 1, 2 )  的 <em>cosine similarity</em> 為：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

& \frac{ 2 \times 1 + 1 \times 0 + 0 \times 0 + 0 \times 0 + 0 \times 0 + 0 \times 0 + 0 \times 1 + 1 \times 1 + 1 \times 1 + 1 \times 2 }{ \sqrt{ 2^2 + 1^2 + 0^2 + 0^2 + 0^2 + 0^2 + 0^2 + 1^2 + 1^2 + 1^2 } \sqrt{ 1^2 + 0^2 + 0^2 + 0^2 + 0^2 + 0^2 + 1^2 + 1^2 + 1^2 + 2^2} } \\

& = \frac{ 6 }{ \sqrt{ 8 } \sqrt{ 8} } 

= 0.75 

\end{align}

 %]]&gt;</script>

<p>而 <em>bird</em> 的向量為：( 1, 0, 0, 0, 0, 1, 0, 0, 1, 1 )  ，計算 <em>dog</em>  和  <em>bird</em> 的 <em>cosine similarity</em> ：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

& \frac{ 2 \times 1 + 1 \times 0 + 0 \times 0 + 0 \times 0 + 0 \times 0 + 0 \times 1 + 0 \times 0 + 1 \times 0 + 1 \times 1 + 1 \times 1 }{ \sqrt{ 2^2 + 1^2 + 0^2 + 0^2 + 0^2 + 0^2 + 0^2 + 1^2 + 1^2 + 1^2 } \sqrt{ 1^2 + 0^2 + 0^2 + 0^2 + 0^2 + 1^2 + 0^2 + 0^2 + 1^2 + 1^2} }  \\

& = \frac{ 4 }{ \sqrt{ 8 } \sqrt{ 4} } 

\approx 0.707106781187 

\end{align}

 %]]&gt;</script>

<p>由於 0.75 &gt; 0.707 ，因此 <em>dog</em> 和 <em>cat</em> 語意比較接近， <em>dog</em> 和 <em>bird</em> 語意比較不同。</p>

<p>此種語意向量有個缺點，就是向量的維度等於總字彙量。例如英文單字種共有好幾萬種，那麼，向量就有好幾萬個維度，向量維度過大的缺點，會造成資料過度稀疏，以及占記憶體的空間。</p>

<p>降低向量維度的方式，有兩種方法，分別是：</p>

<ol>
  <li>
    <p><a href="https://ccjou.wordpress.com/2009/09/01/%E5%A5%87%E7%95%B0%E5%80%BC%E5%88%86%E8%A7%A3-svd/">singular value decompisition (SVD)</a></p>
  </li>
  <li>
    <p><a href="http://blog.csdn.net/itplus/article/details/37969519">word2vec</a></p>
  </li>
</ol>

<p>本文先不詳細介紹這部分。</p>

<h2 id="implementation">Implementation</h2>

<p>在此實作將文字轉成向量，並用 SVD 降為至二維，作視覺化</p>

<p>```python
import numpy as np
import matplotlib.pyplot as plt</p>

<p>text = [
    [“the”, “dog”, “run”, ],
    [“a”, “cat”, “run”, ],
    [“a”, “dog”, “sleep”, ],
    [“the”, “cat”, “sleep”, ],
    [“a”, “dog”, “bark”, ],
    [“the”, “cat”, “meows”, ],
    [“the”, “bird”, “fly”, ],
    [“a”, “bird”, “sleep”, ],
]</p>

<p>def build_word_vector(text):
    word2id = {w: i for i, w in enumerate(sorted(list(set(reduce(lambda a, b: a + b, text)))))}
    id2word = {x[1]: x[0] for x in word2id.items()}
    wvectors = np.zeros((len(word2id), len(word2id)))
    for sentence in text:
        for word1, word2 in zip(sentence[:-1], sentence[1:]):
            id1, id2 = word2id[word1], word2id[word2]
            wvectors[id1, id2] += 1
            wvectors[id2, id1] += 1
    return wvectors, word2id, id2word</p>

<p>def cosine_sim(v1, v2):
    return np.dot(v1, v2) / (np.sqrt(np.sum(np.power(v1, 2))) * np.sqrt(np.sum(np.power(v1, 2))))</p>

<p>def visualize(wvectors, id2word):
    np.random.seed(10)
    fig = plt.figure()
    U, sigma, Vh = np.linalg.svd(wvectors)
    ax = fig.add_subplot(111)
    ax.axis([-1, 1, -1, 1])
    for i in id2word:
        ax.text(U[i, 0], U[i, 1], id2word[i], alpha=0.3, fontsize=20)
    plt.show()</p>

<p>```</p>

<p>本程式中， <code>text</code> 是輸入的文字， <code>build_word_vector</code> 將文字轉成向量：</p>

<p>```sh</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>wvectors, word2id, id2word = build_word_vector(text)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>其中， <code>wvectors</code> 是根據前後文統計後，得出各文字的向量：</p>

<p>```sh</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print wvectors
[[ 0.  0.  1.  1.  2.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  1.  0.  0.  0.  0.  0.]
 [ 1.  0.  0.  0.  0.  1.  0.  0.  1.  1.]
 [ 1.  0.  0.  0.  0.  0.  1.  1.  1.  2.]
 [ 2.  1.  0.  0.  0.  0.  0.  1.  1.  1.]
 [ 0.  0.  1.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  1.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  1.  1.  0.  0.  0.  0.  0.]
 [ 0.  0.  1.  1.  1.  0.  0.  0.  0.  0.]
 [ 0.  0.  1.  2.  1.  0.  0.  0.  0.  0.]]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>每一橫排（或直排）代表著某個字的向量，但從它看不出是哪個字，所以 <code>word2id</code> 則是給定文字，找出是第幾個向量，而 <code>id2word</code> 則是給定第幾個向量，找出所對應的文字。</p>

<p>```sh</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print word2id
{‘a’: 0, ‘fly’: 5, ‘run’: 7, ‘the’: 9, ‘dog’: 4, ‘cat’: 3, 
‘meows’: 6, ‘sleep’: 8, ‘bark’: 1, ‘bird’: 2}</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print id2word
{0: ‘a’, 1: ‘bark’, 2: ‘bird’, 3: ‘cat’, 4: ‘dog’, 5: ‘fly’, 
6: ‘meows’, 7: ‘run’, 8: ‘sleep’, 9: ‘the’}</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>例如 <em>dog</em> 是在 <code>wvectors</code> 中， 第 5 排的向量（註：index 從0開始算），用 <code>word2id</code> 可從 <code>wvector</code> 中，取出其對應向量：</p>

<p>```sh</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print wvectors[word2id[“dog”]]
[ 2.  1.  0.  0.  0.  0.  0.  1.  1.  1.]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>程式碼中的 <code>cosine_sim</code> ，則可計算兩向量間的 <em>cosine similarity</em> ，例如，</p>

<p>計算 <em>dog</em> 和 <em>cat</em> 與 <em>dog</em> 和 <em>bird</em> 之間的  <em>cosine similarity</em>  ：</p>

<p>```sh</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print cosine_sim(wvectors[word2id[“dog”]], wvectors[word2id[“cat”]])
0.75</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print cosine_sim(wvectors[word2id[“dog”]], wvectors[word2id[“bird”]])
0.707106781187</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再來是用 <code>visualize</code> 將這些語意向量在平面上作視覺化：</p>

<p>```sh</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>visualize(wvectors, id2word)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>在平面上作視覺化的方法，是用 SVD 將語意向量降為至二維，就可以把這些向量所對應的字，畫在平面上，結果如下：</p>

<p><img src="/images/pic/pic_00186.png" alt="" /></p>

<p>此結果顯示，   <em>dog</em> 、 <em>cat</em> 和 <em>bird</em> 是語意相近的一群， <em>a</em> 和 <em>the</em> 語意相近，以此類推。</p>

<h2 id="further-reading">Further Reading</h2>

<p>Simple Word Vector representations</p>

<p>http://cs224d.stanford.edu/lectures/CS224d-Lecture2.pdf</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Viterbi Algorithm]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/04/06/natural-language-processing-viterbi-algorithm/"/>
    <updated>2014-04-06T18:21:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/04/06/natural-language-processing-viterbi-algorithm</id>
    <content type="html"><![CDATA[<h2 id="introduction">1.Introduction</h2>

<p>本文接續先前提到的 <em>Hidden Markov Model</em></p>

<p><a href="/blog/2014/04/03/natural-language-processing-hidden-markov-models">Natural Language Processing – Hidden Markov Model</a></p>

<p>繼續探討 <em>part of speech tagging</em> 的演算法</p>

<p>先前提到, 如果要在 <em>Hidden Markov Model</em> 找出一個機率最大的 <em>tagging sequence</em></p>

<p>則必須把每一個序列都列出來, 看哪一個是機率最大的</p>

<p>但如果 <em>Tag</em> 有 <script type="math/tex">N</script> 種, 那麼長度為 <script type="math/tex">T</script> 的序列, 就有 <script type="math/tex">N^{T}</script> 種可能的 <em>tagging sequence</em></p>

<p>由此可知, 暴力列舉的演算法非常沒有效率</p>

<!--more-->

<h2 id="viterbi-algorithm">2.Viterbi Algorithm</h2>

<p>那麼, 來看看暴力列舉法, 到底出了什麼問題</p>

<p>在計算這些序列的機率時, 假設目前已經計算到了第 <script type="math/tex">t</script> 個字 <script type="math/tex">o_{t}</script> , 這個字的 <em>tag</em> 為 <script type="math/tex">r</script> 時, 上一個字的 <em>tag</em>  為 <script type="math/tex">s</script> , 則此種情況發生的機率為</p>

<script type="math/tex; mode=display">

P(q_{t}=r \mid q_{t-1} = s)\times P(X_{t}=o_{t} \mid q_{t} = r)=a_{s,r}\times b_{r}(o_{t}),\mspace{10mu} s \in {i,j,k}

</script>

<p>其中, <script type="math/tex">s</script> 有三種可能, 分別是 <script type="math/tex">i</script> , <script type="math/tex">j</script> ,<script type="math/tex">k</script> </p>

<p>假設在 <script type="math/tex">t-1</script> 之前的序列為 <script type="math/tex">C_{i} , C_{j} , C_{k}</script> ,且在 <script type="math/tex">i,j,k</script> 這三個 <em>state</em> 的機率分別為 <script type="math/tex">c_{i} , c_{j} , c_{k}</script></p>

<p>若是使用暴力列舉法, 要分別計算 <script type="math/tex">C_{i}ir</script> , <script type="math/tex">C_{j}jr</script> , <script type="math/tex">C_{k}kr</script> 這三個序列的機率, 如下圖</p>

<p><img src="/images/pic/pic_00012.png" alt="viterbi1" /></p>

<p>由上圖可知 , 在 <script type="math/tex">r</script> 這個 <em>state</em> ,就多增加了 3 個序列傳遞下去, 之後每個 <em>state</em>  都會因為前面有 <em>N</em> 種不同的 <em>state</em> , 而增加 <em>N</em> 種不同的序列, 這樣一直增加, 序列的數量呈指數函數成長, 最後再一起比誰的機率比較大</p>

<p>這就是造成暴力列舉法沒效率的原因</p>

<p>其實, 可以用 <em>Dynamic Programming</em> 的概念, 在計算每個 <em>state</em>  的機率時, 就直接比較序列的機率大小, </p>

<p>只保留機率最大的一條序列, 傳遞下去, 如下圖</p>

<p><img src="/images/pic/pic_00013.png" alt="viterbi2" /></p>

<p>這樣每一個 <em>state</em> 就只會傳遞一個序列下去, 不會使序列數量呈指數成長</p>

<p>這就是所謂的 <em>Viterbi Algorithm</em></p>

<h2 id="example">3.Example</h2>

<p>舉個例子, </p>

<p>有個研究者, 想根據某地人們生活日記中, 記載每天吃冰淇淋的數量, 來推斷當時的天氣變化如何</p>

<p>在某個地點有兩種天氣, 分別是 <em>Hot</em> 和 <em>Cold</em> , 而當地的人們會記錄他們每天吃冰淇淋的數量, 數量分別為 <em>1</em> , <em>2</em> 或 <em>3</em> , </p>

<p>則可以把天氣變化的機率, 以及天氣吃冰淇淋數量的關係, 用 <em>Hidden Markov Model</em> 表示,</p>

<p>由於天氣是未知的, 為 <em>hidden state</em> , 天氣的集合為 <script type="math/tex">Weather=\{HOT,COLD\}</script></p>

<p>而冰淇淋數量是已知的, 為 <em>observable</em> , 冰淇淋數量的集合為 <script type="math/tex">Icecream=\{1,2,3\}</script></p>

<p>天氣的 <em>Transition Matrix</em> , <script type="math/tex">A</script> , 以及天氣變化對於冰淇淋數量的 <em>Output Matrix</em> , <script type="math/tex">B</script> 如下</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


    A:\begin{array}{c|c}

     _{Day_{t}}\setminus _{Day_{t+1}} & HOT  & COLD \\\hline

    \hline HOT & 0.7 & 0.3 \\

    \hline COLD & 0.4 & 0.6 \\

		\end{array}\mspace{50mu}

    B:\begin{array}{c|c}

     _{Weather}\setminus _{Icecream} & 1  & 2 & 3 \\\hline

    \hline HOT & 0.2 & 0.4 & 0.4 \\

    \hline COLD & 0.5 & 0.4 & 0.1\\

		\end{array}


 %]]&gt;</script>

<p>如果冰淇淋的記錄 <script type="math/tex">(3,1,1)</script> , 用 <em>Viterbi Algorithm</em> 計算看看可能的天氣序列是什麼</p>

<p>首先, 從 <em>initial state</em> 開始, 計算第一個 <em>state</em> 是 <script type="math/tex">H</script> 以及 <script type="math/tex">C</script> 的機率</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&P(X_{1}=3 , q_{1} = H) =  P(q_{1}=H)\times P(X_{1}=3 \mid q_{1} = H) = 0.8 \times 0.4 = 0.32 \\

&P(X_{1}=3 , q_{1} = C) = P(q_{1}=C)\times P(X_{1}=3 \mid q_{1} = C) = 0.2 \times 0.1 = 0.02

\end{align}

 %]]&gt;</script>

<p>計算結果如下圖</p>

<p><img src="/images/pic/pic_00014.png" alt="p1" /></p>

<p>再來, 我們來計算第二個 <em>state</em> 是 <script type="math/tex">H</script> 的機率, 我們分別要算序列 <script type="math/tex">CH</script> 和 <script type="math/tex">HH</script> 的序列</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

& P(X_{1}=3 , q_{1} = H) \times P(q_{2}=H \mid q_{1}=H)\times P(X_{2}=1 \ mid q_{2} = H) 

=0.32 \times 0.7 \times 0.2 = 0.0448 \\

& P(X_{1}=3 , q_{1} = C) \times P(q_{2}=H \mid q_{1}=C)\times P(X_{2}=1 \ mid q_{2} = H) 

=0.02 \times 0.4 \times 0.2 = 0.0016

\end{align}

 %]]&gt;</script>

<p>結果如下圖：</p>

<p><img src="/images/pic/pic_00015.png" alt="p2" /></p>

<p>用 <em>Viterbi Algorithm</em> , 在同一個 <em>state</em> 只需要保留機率最大的序列即可</p>

<script type="math/tex; mode=display">

	max( 0.0448, 0.0016 ) = 0.0448

</script>

<p>因此我們在 <em>state</em> <script type="math/tex">H</script> 上, 只需要保留機率為 <script type="math/tex">0.048</script> 的序列 <script type="math/tex">HH</script> , 傳遞下去, 如下圖</p>

<p><img src="/images/pic/pic_00016.png" alt="p3" /></p>

<p>就用這樣的概念, 之後的每一個 <em>state</em> 都這樣計算, 就會得到每個 <em>state</em> 的機率值, 如下圖</p>

<p><img src="/images/pic/pic_00017.png" alt="p4" /></p>

<p>全部算完後, 再比較序列的最後一個 <em>state</em>, 哪一個機率比較大, 較大者可以傳遞到 <em>end state</em> (也就是最後的答案)</p>

<p>然後, 從 <em>end state</em> 回溯之前保留下來的序列, 如下圖</p>

<p><img src="/images/pic/pic_00018.png" alt="p6" /></p>

<p>得出最有可能的序列是 <em>HCC</em></p>

<p>動畫版：</p>

<p><img src="/images/pic/pic_00019.gif" alt="p7" /></p>

<h2 id="implementation">4.Implementation</h2>

<p>接著我們來實作一下, 先前提到的暴力列舉法, 以及 <em>Viterbi</em> 演算法</p>

<p>並比較這兩者的performance差異</p>

<p>新增一個python script檔案, 檔名為 <code>viterbi.py</code> ,並加入以下程式碼</p>

<p>1.前例中的Model, 和必要模組</p>

<p>```python viterbi.py
import timeit
_STATE=[‘H’,’C’]
_PI={‘H’:.8, ‘C’:.2}
_A={ ‘H’:{‘H’:.7, ‘C’:.3 }, ‘C’:{‘H’:.4,’C’:.6} }
_B={‘H’:{1:.2,2:.4,3:.4}, ‘C’:{1:.5,2:.4,3:.1} }</p>

<p>def p_aij(i, j):
    return _A[i][j]</p>

<p>def p_bik(i, k):
    return _B[i][k]</p>

<p>def p_pi(i):
    return _PI[i]</p>

<p>```</p>

<p>其中, <code>timeit</code> 是用來計時的模組, 用於比較演算法所花的時間, </p>

<p>而 <code>_STATE</code> , <code>_PI</code> 是 <em>state</em> 的種類和 <em>initial state</em> 的機率, </p>

<p><code>_A</code> 和 <code>_B</code> 是 <em>Transition Matrix</em> 和 *Output Matrix’, </p>

<p><code>p_aij(i, j)</code> , <code>p_bik(i, k)</code> , <code>p_pi(i)</code> 分別是 <script type="math/tex">P(q_{t+1} = j \mid q_{t} = i)</script>  ,  <script type="math/tex">P(X_{t} = k , q_{t} = i)</script> 和  <script type="math/tex">\pi_{i}</script></p>

<p>2.暴力列舉法的function: <code>brute_force_algo(obs_init, print_seq=False)</code> </p>

<p>```python viterbi.py
def brute_force_algo(obs_init, print_seq=False):
    start = timeit.default_timer()
    seq_val=[]; 
    def rec(obs, val_pre, qseq_pre):
        if len(obs) &gt;0:
            for q in _STATE:
                if len(qseq_pre) == 0 :
                    val = val_pre * p_pi(q) * p_bik(q, obs[0])
                else:
                    q_pre = qseq_pre[-1]
                    val = val_pre * p_aij(q_pre,q) * p_bik(q, obs[0])
                qseq = qseq_pre + [q]
                rec(obs[1:], val, qseq)
        else:
            seq_val.append((qseq_pre, val_pre))
    rec(obs_init, 1, [])
    if print_seq:
        for (seq,val) in seq_val:
            print ‘seq : %s , value : %s’%(seq, val)
    print ‘result of brute_force_algo:’
    stop = timeit.default_timer()
    print ‘max_seq : %s  max_val : %s’%( 
          reduce(lambda x1,x2: x2 if x2[1] &gt; x1[1] else x1, seq_val))
    print ‘runtime : %s’%(stop - start )</p>

<p>```</p>

<p>其中, input argument <code>obs_init</code> 是 <em>observable</em> , </p>

<p><code>print_seq</code> 是用來控制是否要印出計算過程中產生的序列, 或者只印出最後結果</p>

<p>演算法用 recursive function 的方式實現, 詳細內容在此不詳述, </p>

<p>3.viterbi演算法的function: <code>viterbi_algo(obs_init, print_seq=False)</code></p>

<p>```python viterbi.py
def viterbi_algo(obs_init, print_seq=False):
    start = timeit.default_timer()
    state_snapshot=[]
    def rec(obs, val_pre, qseq_pre):
        if len(obs) &gt; 0:
            val = {}
            qseq = {}
            for q in _STATE:
                if len(val_pre) == 0:
                    val.update({ q:p_pi(q) * p_bik(q, obs[0]) })
                    qseq.update({q:[]})
                    state_snapshot.append(([q],val[q]))
                else:
                    val_temp = [( qseq_pre[q_pre]+[q_pre], 
                                val_pre[q_pre] * p_aij(q_pre,q) * p_bik(q, obs[0] )) 
                                for q_pre in _STATE ] 
                    max_q_seq = reduce(lambda x1,x2: x2 if x2[1] &gt; x1[1] else x1, val_temp)
                    state_snapshot.append((max_q_seq[0]+[q],max_q_seq[1]))
                    val.update({ q:max_q_seq[1]  })
                    qseq.update({ q:max_q_seq[0] })
            return rec(obs[1:],val,qseq)
        else:
            val_temp =[( qseq_pre[q]+[q] , val_pre[q] ) for q in _STATE ] 
            max_q_seq = reduce(lambda x1,x2: x2 if x2[1] &gt; x1[1] else x1, val_temp)
            return max_q_seq  <br />
    seq,val = rec(obs_init, {},[])
    if print_seq:
        for (seq,val) in state_snapshot:
            print ‘seq : %s , value : %s’%(seq, val)
    print ‘result of viterbi_algo:’
    print ‘max_seq : %s , max_value : %s’%(seq, val)
    stop = timeit.default_timer()
    print ‘runtime : %s’%(stop - start )     </p>

<p>```</p>

<p>其中, 所使用的參數, 和暴力列舉法一樣</p>

<p>唯演算法部份改用 <em>Viterbi algorithm</em> , 但也是以 recursive function 的形式寫成, 在此不詳述</p>

<p>接著到interactive mode 載入 viterbi.py</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import viterbi</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>先來看一下暴力列舉法</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>viterbi.brute_force_algo([3,1,1],True)
seq : [‘H’, ‘H’, ‘H’] , value : 0.006272
seq : [‘H’, ‘H’, ‘C’] , value : 0.00672
seq : [‘H’, ‘C’, ‘H’] , value : 0.00384
seq : [‘H’, ‘C’, ‘C’] , value : 0.0144
seq : [‘C’, ‘H’, ‘H’] , value : 0.000224
seq : [‘C’, ‘H’, ‘C’] , value : 0.00024
seq : [‘C’, ‘C’, ‘H’] , value : 0.00048
seq : [‘C’, ‘C’, ‘C’] , value : 0.0018
result of brute_force_algo:
max_seq : [‘H’, ‘C’, ‘C’]  max_val : 0.0144
runtime : 0.000172138214111</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>暴力列舉法會列出所有的序列, 並找出機率最大的序列</p>

<p>再來是 <em>viterbi algorithm</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>viterbi.viterbi_algo([3,1,1],True)
seq : [‘H’] , value : 0.32
seq : [‘C’] , value : 0.02
seq : [‘H’, ‘H’] , value : 0.0448
seq : [‘H’, ‘C’] , value : 0.048
seq : [‘H’, ‘H’, ‘H’] , value : 0.006272
seq : [‘H’, ‘C’, ‘C’] , value : 0.0144
result of viterbi_algo:
max_seq : [‘H’, ‘C’, ‘C’] , max_value : 0.0144
runtime : 0.000169038772583</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><em>Viterbi algorithm</em> 不會把每個序列都列出來, 而是用 <em>Dynamic Programming</em> 的方式, 保留下比較有可能的 <em>subsequence</em> , 最後也可以得出正確結果 , 且runtime比暴力列舉法快</p>

<p>再來, 增加一下input sequence的長度, 讓這兩種演算法的差異突顯出來, </p>

<p>為了避免印出過多序列, 第二個參數輸入 <code>False</code> , 如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>viterbi.brute_force_algo([3,1,1,2]*4,False)
result of brute_force_algo:
max_seq : [‘H’, ‘C’, ‘C’, ‘H’, ‘H’, ‘C’, ‘C’, ‘H’, ‘H’, ‘C’, ‘C’, ‘H’, ‘H’, ‘C’, ‘C’, ‘C’]  max_val : 2.83168745718e-11
runtime : 0.245212078094</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>viterbi.viterbi_algo([3,1,1,2]*4,False)
result of viterbi_algo:
max_seq : [‘H’, ‘C’, ‘C’, ‘H’, ‘H’, ‘C’, ‘C’, ‘H’, ‘H’, ‘C’, ‘C’, ‘H’, ‘H’, ‘C’, ‘C’, ‘C’] , max_value : 2.83168745718e-11
runtime : 0.000442981719971</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>比較一下, 暴力列舉法的 <em>runtime</em> 呈指數函數成長, 而 <em>viterbi algorithm</em> 的是呈多項式函數成長</p>

<h2 id="reference">5. Reference</h2>

<p>本文參考至兩本教科書</p>

<p><a href="http://www.amazon.com/Foundations-Statistical-Natural-Language-Processing/dp/0262133601">Foundations of Statistical Natural Language Processing</a></p>

<p><a href="http://www.amazon.com/Speech-Language-Processing-2nd-Edition/dp/0131873210">Speech and Language Processing</a></p>

<p>以及台大資工系 陳信希教授的 自然語言處理 課程講義</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Davidsonian Event Semantics]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/04/04/formal-semantics-davidsonian-event-semantics/"/>
    <updated>2014-04-04T17:13:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/04/04/formal-semantics-davidsonian-event-semantics</id>
    <content type="html"><![CDATA[<h2 id="introduction">1.Introduction</h2>

<p>所謂的形式語義學( <em>Formal Semantics</em> ), 是在研究, 如何把自然語言用邏輯形式來表達</p>

<p>例如以下句子</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\text{John buttered the toast.} &(1.a)

\end{align}

 %]]&gt;</script>

<p>傳統上, 用一皆邏輯 <em>First Order Logic</em> 可以把這個句子表示成這樣</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&butter(John,toast) &(1.b)

\end{align}

 %]]&gt;</script>

<!--more-->

<p>其中, <em>butter</em> 這個邏輯式的predicate, 而 <em>John</em> 和 <em>toast</em> 分別是argument, 這個邏輯式表示了 <em>John</em> 和 <em>toast</em> 的關係, </p>

<p>當這句話為真的時候, </p>

<script type="math/tex; mode=display">

butter(John,toast) \equiv True

</script>

<p>如果現在句子是這樣, 有個介繫詞片語修飾, 例如：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\text{John butterd the toast with the knife} &(2.a) 

\end{align}

 %]]&gt;</script>

<p>則可以把 <script type="math/tex">(1.b)</script> 的一階邏輯式,再加入一個論元 (argument) 擴充成這樣</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&butter(John,toast,knife) &(2.b) 

\end{align}

 %]]&gt;</script>

<p>但這方法有個缺點, 就是無法推論 <script type="math/tex">(2.b)</script> 這個邏輯式是否蘊含 <script type="math/tex">(1.b)</script></p>

<script type="math/tex; mode=display">

butter(John,toast,knife) \nrightarrow butter(John,toast)

</script>

<p>而事實上, <script type="math/tex">(2.a)</script> 這句話蘊含 <script type="math/tex">(1.a)</script> , 是成立的</p>

<script type="math/tex; mode=display">

\text{John butterd the toast with the knife} \rightarrow \text{John buttered the toast.}

</script>

<p>照理說, 邏輯式要可以表達這些自然語言中的蘊含關係</p>

<p>因此就要想出一個邏輯表達方法, 也可以讓這些蘊含推論成立</p>

<h2 id="davidsonian-event-semantics">2.Davidsonian event semantics</h2>

<p><em>Davidson</em> 在 1969 年提出了 <em>event</em> 的概念 </p>

<blockquote>
  <p>what adverbial clauses modify is not verbs but the events that certain verbs introduce.
Davidson (1969/1980: 167)</p>
</blockquote>

<p>意思就是, 修飾動詞的修飾語, 其實是在修飾這個動詞引出的事件</p>

<p>例如, 針對句子 <script type="math/tex">(1.a)</script>  , 可以把動詞 <em>butter</em> 引出的事件定為 <script type="math/tex">e</script> , 並加到 <script type="math/tex">(1.b)</script> 中 <em>butter</em>的argument,如下：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\exists e  (butter(John,toast,e)) &(1.c)

\end{align}

 %]]&gt;</script>

<p>其中, 式子前面的 <script type="math/tex">\exists e</script> 表示, 當這個式子成立的時候, 存在 <script type="math/tex">e</script> 這樣一個事件</p>

<p>然後, 句子 <script type="math/tex">(2.a)</script> 的邏輯式也可以用 <em>event</em> 的概念擴充, 可以把修飾語 <em>with a knife</em> 替換成 <script type="math/tex">instr(e,knife)</script>,  表示執行這個 <em>event</em> 的 <em>instrument</em> 為 <em>knife</em> , 如下：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\exists e  (butter(John,toast,e)\wedge instr(e,knife)) &(2.c)

\end{align}

 %]]&gt;</script>

<p>來檢查一下邏輯式 <script type="math/tex">(2.c)</script> 是否蘊含 <script type="math/tex">(1.c)</script></p>

<script type="math/tex; mode=display">

\exists e  (butter(John,toast,e)\wedge instr(e,knife)) \rightarrow \exists e  (butter(John,toast,e))

</script>

<p>以上蘊含成立</p>

<p>除此之外, 一個動詞可能同時被很多個介繫詞片與修飾, 例如以下句子</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

\text{John buttered the toast in the bathroom with the knife at midnight} &(3.a)

\end{align}

 %]]&gt;</script>

<p><script type="math/tex">(3.a)</script> 不但蘊含 <script type="math/tex">(2.a)</script> 也蘊含 <script type="math/tex">(1.a)</script></p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\text{John buttered the toast in the bathroom with the knife at midnight} &(3.a) \\

&\rightarrow  

\text{John butterd the toast with the knife} &(2.a)  \\

&\rightarrow 

\text{John buttered the toast.} &(1.a) \\

\end{align}

 %]]&gt;</script>

<p>這種句子如果用沒有引入 <em>event</em> 的概念, 用 <script type="math/tex">(2.b)</script> 的傳統邏輯式子, 問題就更大了</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&butter(John,toast,knife,bathroom,midnight) &(3.b) 

\end{align}

 %]]&gt;</script>

<p>這樣的話, 我們就要定義 <em>butter</em> 可以接收很多個argument, 且要定好哪個位置是填給哪一種修飾語用的, 當然, <script type="math/tex">(3.b)</script> 蘊含 <script type="math/tex">(2.b)</script> 的推論也不成立</p>

<p>用 <em>event</em> 的概念就簡單很多了, 不用修改到 <em>butter</em> 的argument, 只要把修飾語轉換成修飾 <script type="math/tex">e</script> 的predicate, 並和 <em>butter</em> 做conjunction, 就可以了, 如下</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\exists e  (butter(John,toast,e)\wedge instr(e,knife) \wedge in(e,bathroom) \wedge at(e,midnight) ) &(3.c)

\end{align} 

 %]]&gt;</script>

<p>而且 <script type="math/tex">(3.c)</script> 蘊含 <script type="math/tex">(2.c)</script> 也蘊含 <script type="math/tex">(1.c)</script> </p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\exists e  (butter(John,toast,e)\wedge instr(e,knife) \wedge in(e,bathroom) \wedge at(e,midnight) ) &(3.c) \\

&\rightarrow \exists e  (butter(John,toast,e)\wedge instr(e,knife)) &(2.c) \\

&\rightarrow \exists e  (butter(John,toast,e)) &(1.c) \\

\end{align}

 %]]&gt;</script>

<h2 id="implementation">3.Implementation</h2>

<p>來載入模組, 實作看看</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk.sem.logic as logic
from nltk import Prover9
lgp = logic.LogicParser()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>用前面提到的句子和邏輯式子來做練習</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\text{John buttered the toast.} &(1.a) \\

&\text{John butterd the toast with the knife} &(2.a)  \\

&\text{John buttered the toast in the bathroom with the knife at midnight} &(3.a) \\

\\

& \exists e  (butter(John,toast,e)) &(1.c) \\

& \exists e  (butter(John,toast,e)\wedge instr(e,knife)) &(2.c) \\

&\exists e  (butter(John,toast,e)\wedge instr(e,knife) \wedge in(e,bathroom) \wedge at(e,midnight) ) &(3.c) \\

\end{align}

 %]]&gt;</script>

<p>把 <script type="math/tex">(1.a)</script> , <script type="math/tex">(2.a)</script> , <script type="math/tex">(3.a)</script> , 這三句話的邏輯式  <script type="math/tex">(1.c)</script> , <script type="math/tex">(2.c)</script> , <script type="math/tex">(3.c)</script> 分別輸入到LogicParser, 如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>a1 = lgp.parse(‘exists e ( butter(John,toast,e))’)
a2 = lgp.parse(‘exists e ( butter(John,toast,e) &amp; instr(e,knife) )’)
a3 = lgp.parse(‘exists e (butter(John,toast,e) &amp; instr(e,knife) &amp; in (e,bathroom) &amp; at(e,midnight) )’)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著來看看句子 <script type="math/tex">(1.a)</script> 和 <script type="math/tex">(2.a)</script> 的蘊含關係</p>

<p>用 <code>Prover9()</code> 來證明, 我們把未知值的句子放在第一個argument ,  已知為真的句子放在第二個argument中</p>

<p>例如, 想要證明當  <script type="math/tex">(2.a)</script> 為真時, <script type="math/tex">(1.a)</script> 是否為真, 輸入方法如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Prover9().prove(a1, [a2])
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>結果顯示, 當 <script type="math/tex">(2.a)</script> 為真, <script type="math/tex">(1.a)</script> 必為真, 表示 <script type="math/tex">(2.a)</script>  蘊含 <script type="math/tex">(1.a)</script> </p>

<p>把 <script type="math/tex">(2.a)</script> 和 <script type="math/tex">(1.a)</script> 對調</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Prover9().prove(a2, [a1])
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>結果顯示, <script type="math/tex">(1.a)</script> 蘊含 <script type="math/tex">(2.a)</script> 不成立</p>

<p>然後來看看 <script type="math/tex">(3.a)</script> 和 <script type="math/tex">(2.a)</script> 以及 <script type="math/tex">(1.a)</script> 的蘊含關係</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Prover9().prove(a2, [a3])
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Prover9().prove(a1, [a3])
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>結果顯示, <script type="math/tex">(3.a)</script> 蘊含 <script type="math/tex">(2.a)</script> 也蘊含 <script type="math/tex">(1.a)</script></p>

<h2 id="reference">4. Reference</h2>

<p>本文參考至以下這本語意學書籍</p>

<p><a href="http://www.amazon.com/Semantics-International-Handbooks-Linguistics-Communication/dp/3110184702">Semantics: An International Handbook of Natural Language Meaning</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NLTK Logic 4 : Model and Satisfiability]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/03/29/python-nltk-logic-4/"/>
    <updated>2014-03-29T15:39:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/03/29/python-nltk-logic-4</id>
    <content type="html"><![CDATA[<h2 id="model-and-satisfiability">1.Model and Satisfiability</h2>

<p>可滿足性(Satisfiability)是在探討, 邏輯式子所建立出的模型(Model),</p>

<p>可不可以找到一組解, 使得這個 <em>Model</em> 算出來的值可以是 <script type="math/tex">True</script></p>

<p>例如：</p>

<script type="math/tex; mode=display">

p1=(x \vee y), \mspace{5mu}

p2=(\neg x \vee y),  \mspace{5mu}

p3=(x \vee \neg y) \\

M1=p1 \wedge p2 \wedge p3

</script>

<p>則當 <script type="math/tex">x\equiv True, \mspace{5mu} y \equiv  True</script> 時, <script type="math/tex">M1 \equiv True </script></p>

<p>則 <em>Model</em> <script type="math/tex">M1</script> 是 <em>Satisfiable</em></p>

<p>另一例子：</p>

<script type="math/tex; mode=display">

p1=(x \vee y), \mspace{5mu}

p2=(\neg x \vee y),  \mspace{5mu}

p3=(x \vee \neg y) \mspace{5mu}

p4=(\neg x \vee \neg y)\\

M2=p1 \wedge p2 \wedge p3 \wedge p4

</script>

<p>這種情形,不論 <script type="math/tex">x</script> 或 <script type="math/tex">y</script> 的值,  <script type="math/tex">M2</script> 永遠都是 <script type="math/tex">False</script></p>

<p>則 <em>Model</em> <script type="math/tex">M2</script> 是 <em>Unsatisfiable</em></p>

<!--more-->

<h2 id="implementation-1">2.Implementation 1</h2>

<p>接著我們用nltk來做簡單的 <em>Satisfiability</em> 問題</p>

<p>先載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk
lgp = nltk.LogicParser()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著,輸入邏輯式子<script type="math/tex">p1=(x \vee y), \mspace{5mu} p2=(\neg x \vee y),  \mspace{5mu}p3=(x \vee \neg y) \mspace{5mu}</script></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <table>
        <tbody>
          <tr>
            <td>p1 = lgp.parse(‘x</td>
            <td>y’)</td>
          </tr>
          <tr>
            <td>p2 = lgp.parse(‘-x</td>
            <td>y’)</td>
          </tr>
          <tr>
            <td>p3 = lgp.parse(‘x</td>
            <td>-y’)</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>然後把assignment加進去, 看看 <script type="math/tex">M1=p1 \wedge p2 \wedge p3</script> 是否 <em>satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>val = nltk.Valuation([(‘x’, True), (‘y’, True)])
dom = val.domain
g = nltk.Assignment(dom)
m = nltk.Model(dom, val)
m.satisfy(p1 &amp; p2 &amp; p3, g ) 
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再把 <script type="math/tex">p4=(\neg x \vee \neg y)</script> 加進去, 看看<script type="math/tex">M2=p1 \wedge p2 \wedge p3 \wedge p4</script> 是否 <em>satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>p4 = lgp.parse(‘-x | -y’)
m.satisfy(p1 &amp; p2 &amp; p3 &amp; p4, g ) 
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="first-order-logic">3. First Order Logic</h2>

<p>接著我們來看看如何將 <em>Model</em> 和 <em>Satisfiability</em> 的概念, 推廣到一階邏輯(First Order Logic)中</p>

<p>例如,在某個世界裡,</p>

<p><em>Gary</em> 是個男生, <em>Judy</em> 是個女生, 而 <em>Henry</em> 是一隻狗,</p>

<p><em>Gary</em> 和 <em>Henry</em> 在跑步, </p>

<p><em>Judy</em> 看見 <em>Henry</em> 而 <em>Gary</em> 看見 <em>Judy</em></p>

<p>我們可以用一階邏輯(First Order Logic)把這個世界表示成一個 <em>Model</em>：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&M=\\

& Gary(g)  &\wedge \mspace{15mu} & Judy(j)  &\wedge \mspace{15mu} &Henry(h) &\wedge\\

& Boy(g)   &\wedge \mspace{15mu} & Girl(j)  &\wedge \mspace{15mu} &Dog(h)   &\wedge\\

& Run(g)   &\wedge \mspace{15mu} & Run(h)   &\wedge \mspace{15mu} & & \\

& See(j,h) &\wedge \mspace{15mu} & See(g,j) &\wedge \mspace{15mu} &See(g,h)

\end{align}

 %]]&gt;</script>

<p>根據這個Model, 用<em>Satisfiability</em>的概念, 可以求解以下問題</p>

<p>1 . 找找看這個世界中女生有哪些</p>

<p>這個問題可以看成是, 從找 <em>M</em> 中找出滿足 <script type="math/tex">girl(x)</script> 的 <script type="math/tex">x</script> 值有哪些, </p>

<p>可求解 <script type="math/tex">girl(x) \wedge M </script> 的 <em>Satisfiability</em> , 得出：</p>

<p>女生有 <em>Judy</em> , 因為當 <script type="math/tex">x=j</script> 時, <script type="math/tex">girl(x) \wedge M </script> 為 <em>Satisfiable</em></p>

<p>2 . 回答這個世界中是否有男生在跑步, 或者, 是否有女生在跑步</p>

<p>這可以看成是, 判斷某個 formula 和這個 <em>M</em> 是否有交集, 得出：</p>

<p>有男生在跑步, 因為 <script type="math/tex">\exists x(Run(x) \wedge boy(x) ) </script> 在 <script type="math/tex"> M </script> 中為 <em>Satisfiable</em></p>

<p>沒有女生在跑步, 因為 <script type="math/tex">\exists x(Run(x) \wedge girl(x) ) </script> 在 <script type="math/tex"> M </script> 中為 <em>Unsatisfiable</em></p>

<p>3 . 回答是否 <em>Judy</em> 看見 <em>Henry</em> , 或者,是否 <em>Judy</em> 看見 <em>Gary</em></p>

<p>可以判斷某個assignment 是否可讓 <em>M</em> 為 <em>Satisfiable</em> , 得出：</p>

<p><em>Judy</em> 看見 <em>Henry</em> , 因為當 <script type="math/tex">x=j,y=h</script> 時, <script type="math/tex">See(x,y) </script> 在 <script type="math/tex">M </script> 中為 <em>Satisfiable</em></p>

<p><em>Judy</em> 沒有看見 <em>Gary</em> , 因為當<script type="math/tex">x=j,y=g</script> 時, <script type="math/tex">See(x,y) </script> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<p>註：</p>

<p>1.在 python nltk 用的是 <em>Closed World Assumption</em> </p>

<p>也就是說, 在 <em>Model</em> 裡面沒有定義的, 一律為 <em>False</em></p>

<p>例如沒有定義 <em>Run(j)</em> , 所以 <em>Run(j)</em> 為 <em>False</em> </p>

<p>因此 <script type="math/tex">\exists x(Run(x) \wedge girl(x) ) </script> 在 <script type="math/tex"> M </script> 中為 <em>Unsatisfiable</em> </p>

<p>同理, <em>See(j,g)</em> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<p>2.相對於 <em>Closed World Assumption</em> </p>

<p>有另一種叫作 <em>Open World Assumption</em> </p>

<p>是將沒有定義的formula 它視為 <em>Unknown</em></p>

<p>所以結果除了 <em>True</em> 和 <em>False</em> 之外, 還有 <em>Unknown</em></p>

<h2 id="implementation-2">4.Implementation 2</h2>

<p>用 python nltk 來實作看看：</p>

<p>首先, 建立 model</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>v = “”” 
… Gary =&gt; g
… Judy =&gt; j
… Henry =&gt; h
… boy =&gt; {g}
… girl =&gt; {j}
… dog =&gt; {h}
… run =&gt; {g, h}
… see =&gt; {(j, h), (g, j), (g, h)}
… “””</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>val = nltk.parse_valuation(v)
m = nltk.Model(val.domain, val)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>1.求 <script type="math/tex">girl(x)</script> 的 <script type="math/tex">x</script> 值:</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfiers(lgp.parse(‘girl(x)’), ‘x’  , nltk.Assignment(val.domain, []))
set([‘j’])</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>得出結果 <script type="math/tex">x=j</script></p>

<p>2.求 <script type="math/tex">\exists x (Run(x) \wedge boy(x)) </script> 或 <script type="math/tex">\exists x (Run(x) \wedge girl(x))</script> 這兩個formula在 <script type="math/tex">M</script> 中是否為 <em>Satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘exists x.(run(x) &amp; boy(x))’),nltk.Assignment(val.domain, []))
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘exists x.(run(x) &amp; girl(x))’),nltk.Assignment(val.domain, []))
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>得出結果：</p>

<p><script type="math/tex">\exists x(Run(x) \wedge boy(x) )</script> 在 <script type="math/tex">M </script> 中為 <em>Satisfiable</em></p>

<p><script type="math/tex">\exists x(Run(x) \wedge girl(x) ) </script> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<p>3.求 <script type="math/tex">x=j,y=h</script> 或 <script type="math/tex">x=j,y=g</script> 對於 <script type="math/tex">See(x,y)</script> 在 <script type="math/tex">M</script> 中是否為 <em>Satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘see(x,y)’),nltk.Assignment(val.domain,[(‘x’, ‘j’), (‘y’, ‘h’)]))
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘see(x,y)’),nltk.Assignment(val.domain,[(‘x’, ‘j’), (‘y’, ‘g’)]))
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>得出結果：</p>

<p>當 <script type="math/tex">x=j,y=h</script> 時, <script type="math/tex">See(x,y) </script> 在 <script type="math/tex">M </script> 中為 <em>Satisfiable</em></p>

<p>當<script type="math/tex">x=j,y=g</script> 時, <script type="math/tex">See(x,y)</script> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<h2 id="reference">5.Reference</h2>

<p>關於python nltk的 <em>model</em> 和 <em>satistiability</em> 可參考：</p>

<p>http://nltk.googlecode.com/svn/trunk/doc/book/ch10.html</p>

<p>關於 <em>Closed World Assumption</em> 與 <em>Open World Assumption</em> 可參考：</p>

<p>http://en.wikipedia.org/wiki/Closed_world_assumption</p>

<p>http://en.wikipedia.org/wiki/Open_world_assumption</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NLTK Logic 3 : Discourse Representation Theory]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/03/21/python-nltk-logic-3/"/>
    <updated>2014-03-21T03:58:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/03/21/python-nltk-logic-3</id>
    <content type="html"><![CDATA[<h2 id="introduction">1. Introduction</h2>

<p><em>Discourse</em> 的意思是對話</p>

<p>在對話中,常常會用到 <strong>代名詞</strong> ,像是 <em>he</em>, <em>she</em> 或 <em>it</em>.</p>

<p>我們把這種代名詞叫做 <em>anaphoric pronouns</em></p>

<p>因為要從前面的句子去判斷,這些代名詞代表什麼</p>

<p>比如有個句子 <em>A woman walks. She smokes.</em></p>

<p>在下一句的 <em>She</em> 是指前一句提到的 <em>A woman</em></p>

<p>那要怎麼讓電腦去判斷, <strong>代名詞</strong> 到底代表前面提到的什麼？</p>

<p>這就要用到 <em>Discourse Representation Theory (DRT)</em> 來處理了</p>

<p>例如 <em>A woman walks</em> 這句話,用 <em>DRT</em> 可以表示成這樣：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline x  \\ \hline

    	woman(x) \\

      walk(x) \\

    \hline

		\end{array}

</script>

<!--more-->

<p>這樣一個框框的結構叫作 <em>Discourse Representation Structure</em> ,簡稱 <em>DRS</em></p>

<p>其中位於方框上面的 <script type="math/tex">x</script> 叫做 <em>Discourse Referent</em> </p>

<p>它代表這個句子中,可以被其他代名詞參考的東西</p>

<p>方框下方的式子叫做 <em>DRS conditions</em> </p>

<p>它代表這些文句所產生的情境</p>

<p>第二個句子 <em>She smokes.</em></p>

<p>用 <em>DRT</em> 表示成這樣：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline y  \\ \hline

      PRO(y) \\

      smoke(y) \\

    \hline

		\end{array}

</script>

<p>其中, <script type="math/tex">PRO(y)</script> 表示 <script type="math/tex">y</script> 是一個代名詞,但不知道它代表誰</p>

<p>這個時候就要用 <em>DRT</em> ,把對話中前後語句的情境結合起來</p>

<p>就可以進行 <em>Resolve Anaphora</em> 找出代名詞代表什麼</p>

<p>例如：</p>

<p><em>A woman walks. She smokes.</em></p>

<p>用 <em>DRT</em> 表示成：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline x  \\ \hline

    	woman(x) \\

      walk(x) \\

    \hline

		\end{array}

    +

    \begin{array}{|c|}

    \hline y  \\ \hline

      PRO(y) \\

      smoke(y) \\

    \hline

		\end{array}

    \xrightarrow{Simplify}

    \begin{array}{|c|}

    \hline x,y  \\ \hline

    	woman(x) \\

      walk(x) \\

      PRO(y) \\

      smoke(y) \\

    \hline

		\end{array}

    \xrightarrow{Resolve\mspace{5mu} Anaphora}

    \begin{array}{|c|}

    \hline x,y  \\ \hline

    	woman(x) \\

      walk(x) \\

      x = y \\

      smoke(y) \\

    \hline

		\end{array}

</script>

<p>藉由 <em>DRT</em> ,我們可以知道 <em>She</em> 是指 <em>A woman</em></p>

<p>然後,還可以把 <em>DRS</em> 轉成一階邏輯的式子：</p>

<p>像這樣：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline x,y  \\ \hline

    	woman(x) \\

      walk(x) \\

      x = y \\

      smoke(y) \\

    \hline

		\end{array}

    \Rightarrow

    \exists x \exists y.( woman(x) \wedge walk(x) \wedge (x = y) \wedge smoke(y))

</script>

<h2 id="drt-in-nltk">2. DRT in nltk</h2>

<p>現在我們來用nltk實作看看</p>

<p>先載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著我們輸入 <em>A woman walks</em> 的 <em>DRT</em> </p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>dp = nltk.DrtParser()
drs1 = dp.parse(‘([x], [woman(x), walk(x)])’) 
print drs1
([x],[woman(x), walk(x)])</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>我們也可以把 <em>DRT</em> 的結構畫出來</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs1.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>像這樣</p>

<p><img src="http://lh6.googleusercontent.com/-89PLq9VYopQ/UyvQx-TxTfI/AAAAAAAAAqY/cU232E7UWKQ/s165-no/DRT.png" /></p>

<p>接著我們把第二句話 <em>She smokes.</em> 也一起輸入</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs2 = dp.parse(‘([y], [PRO(y),smokes(y)])’) 
drs2.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh3.googleusercontent.com/-ugJ-AhsCo28/Uyva__Uz4QI/AAAAAAAAAqw/wgYKB9yYOcI/w163-h165-no/DRT2.png" /></p>

<p>其中 <code>PRO(y)</code> 是未知的代名詞,</p>

<p>因為只看這句話不知道這個代名詞代表什麼, </p>

<p>需要和第一句話結合起來才知道</p>

<p>我們可以用 <code>+</code> 把這 <em>兩個DRS</em> 合起來</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs3=drs1+drs2
drs3.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh6.googleusercontent.com/-ZVVEazh0bxU/Uyva_xl9HZI/AAAAAAAAArE/FOh2NjrkihE/w335-h158-no/DRT3.png" /></p>

<p>再用 <code>simplify()</code> 把這兩個 <em>DRS</em> 簡化成一個</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs4=drs3.simplify()
drs4.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh6.googleusercontent.com/-XS97Rkd11iM/Uyva_tAb7oI/AAAAAAAAArU/ga7l4KP5QV4/w165-h240-no/DRT4.png" /></p>

<p>然後再用 <code>resolve_anaphora()</code> 找出代名詞 <code>PRO(y)</code> 代表什麼</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs5=drs4.resolve_anaphora()
drs5.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh6.googleusercontent.com/-xqOOLlm0h7w/UyvbAKBA7RI/AAAAAAAAAq8/KOkSJP2nJG4/w168-h240-no/DRT5.png" /></p>

<p>這時,原本的 <code>PRO(y)</code>  會變成 <code>(y = x)</code> 表示已經找出了 <code>y</code> 代表什麼</p>

<p>然後, 還可以把 <em>DRS</em> 轉成 <em>First-order Logic</em> 的式子</p>

<p>像這樣：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>f1=drs5.fol()
print f1
exists x y.(woman(x) &amp; walks(x) &amp; (y = x) &amp; smokes(y))</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣就大功告成了</p>

<h2 id="further-reading">3.Further Reading</h2>

<p>其實 <em>DRT</em> 還可以解決許多關於對話中的語意問題</p>

<p>有興趣的話可以看這個網站：Discourse Representation Theory </p>

<p>http://www.coli.uni-saarland.de/projects/milca/courses/comsem/html/node205.html</p>

<p>以及這本書：</p>

<p><em>Hans Kamp, Josef van Genabith, Uwe Reyle. Discourse Representation Theory</em></p>
]]></content>
  </entry>
  
</feed>
