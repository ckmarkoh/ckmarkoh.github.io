<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Mark Chang's Blog]]></title>
  <link href="http://ckmarkoh.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://ckmarkoh.github.io/"/>
  <updated>2016-12-10T23:54:23+08:00</updated>
  <id>http://ckmarkoh.github.io/</id>
  <author>
    <name><![CDATA[Mark Chang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Built-in Functions -- Eval and Execute]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/04/23/python-built-in-functions-exec/"/>
    <updated>2014-04-23T01:59:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/04/23/python-built-in-functions-exec</id>
    <content type="html"><![CDATA[<h2 id="introduction">1.Introduction</h2>

<p>如果要把 <em>string</em> 的內容, 當成程式碼來執行, 可以用到 <em>eval</em> 或 <em>exec</em></p>

<p>例如有個 <em>string</em> , 為 <code>s1="3+5"</code> 我們想要算它執行的結果, 可用</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>s1=”3+5”
eval(s1)
8</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>來看一下怎麼用 <em>eval</em> 或 <em>exec</em> </p>

<h2 id="eval">2. eval</h2>

<p><code>eval</code> 是當我們要計算某一個字串中的運算, 並且 <strong>會回傳計算結果</strong> ,如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(‘3+1’)
4</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<!--more-->

<p>除了用於數字, 也可用於其他 <em>type</em> , 例如 <em>list</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(‘[3,4,5]+[2]’)
[3, 4, 5, 2]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>或是我們要呼叫 <em>object</em> 的 <em>method</em> 也可以</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(‘“234232”.replace(“2”,”@”)’)
‘@34@3@’</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h3 id="eval-with-variable-and-function">2.1. eval with variable and function</h3>

<p><em>eval</em> 可以用於自訂變數</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>x = 3
eval(‘x+2’)
5</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>````</p>

<p>或是自訂的 <em>function</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>def myfun(y):
…     return y+4
… </p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(‘myfun(x)’)
7</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>也可用於自訂變數的 <em>method</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>a=[1,2]
eval(‘a.reverse()’)
print a
[2, 1]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h3 id="eval-with-builtins">2.2. eval with builtins</h3>

<p>當然, <em>eval</em> 也可用於 <em>built-in function</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(‘abs(-3)’)
3</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>也可以限制 <em>built-in function</em> 的使用</p>

<p>例如在 <em>eval</em> 的第二個 <em>argument</em> 輸入 <code>{"__builtins__" : None }</code> , 如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(‘abs(-3)’,{“<strong>builtins</strong>” : None })
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
NameError: name 'abs' is not defined</module></string></module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h3 id="eval-with-restricted-variable">2.3. eval with restricted variable</h3>

<p>為了避免 <em>eval</em> 不小心變更到程式裡面的某些 <em>variable</em> 的值, 我們可以用以下方法, 限制 <em>eval</em> 可以使用的 <em>variable</em> </p>

<p>例如, 有三個 <em>variable</em> , 分別為 <code>pb1</code> , <code>pb2</code> 與 <code>pr1</code> , 其中, 我們只希望 <em>eval</em> 可以使用 <code>pb1</code> 和 <code>pb2</code> 兩個 <em>variable</em> , 則可以建立一個 <code>dict</code> 來限制, 如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>pb1 = 123
pb2 = [12,13,14]
pr1 = 456
pblist = [‘pb1’,’pb2’]
pbdict = dict([ (k, locals().get(k, None)) for k in pblist ])
print pbdict
{‘pb1’: 123, ‘pb2’: [12, 13, 14]}</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>其中, <code>pbdict</code> 限制了 <em>eval</em> 可以使用哪些 <em>variable</em> , 把 <code>pbdict</code> 放在 <em>eval</em> 的第三個 <em>argument</em> , 如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(“pb1+2”, None, pbdict)
125</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(“pb2[2]+3”, None, pbdict)
17</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>結果顯示, 有在 <code>pbdict</code> 裡面的 <em>variable</em> 可以使用, 但沒在 <code>pbdict</code> 裡面的 <em>variable</em> 就不可以使用了, 如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(“pr1+3”, None, pbdict)
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
NameError: name 'pr1' is not defined</module></string></module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h3 id="restriction-on-eval">2.4. restriction on eval</h3>

<p>並不是所有的<em>expression</em> 都可以用 <em>eval</em> , 例如, <em>assignment</em> 就不能用於 <em>eval</em> , 如下</p>

<p>```</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eval(‘a=3’)
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
  File "<string>", line 1
    a=3
     ^
SyntaxError: invalid syntax</string></module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>或是其他跟 <em>assignment</em> 有關的 <em>operator</em> 也不行</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>a=[1,2]
eval(‘a+=[3]’)
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
  File "<string>", line 1
    a+=[3]
      ^
SyntaxError: invalid syntax</string></module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這時就需要用到 <em>exec</em> 了</p>

<h2 id="exec">3. exec</h2>

<p><em>exec</em> 是把字串當成程式碼來執行, 但是 <strong>不會回傳結果</strong> , 如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(‘3+5’)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>如果要印出結果, 則要加個 <em>print</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(‘print 3+5’)
8</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h3 id="exec-with-variable">3.1. exec with variable</h3>

<p><em>exec</em> 也可以用於 <em>variable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>x = 3
exec(‘x+3’)
print x
3</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>也可用於自訂的 <em>function</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>def myfun(y):
…     return y+4
… </p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(‘myfun(x)’)
print x
3</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>和 <em>eval</em> 不同的是, <em>exec</em> 可以用於 <em>assignment</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(‘z = 5’)
print z
5</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>以及其他和 <em>assignment</em> 相關的 <em>operator</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(‘x += 1’)
print x
4</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h3 id="exec-with-builtins">3.2. exec with builtins</h3>

<p><em>exec</em> 可以用於 <em>built-in function</em> </p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(“print abs(-3)”)
3</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>也可以用 <code>{"__builtins__" : None }</code> 限制 <em>built-in function</em> 的使用</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(“print abs(-3)”,{“<strong>builtins</strong>” : None })
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
NameError: name 'abs' is not defined</module></string></module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h3 id="exec-with-restricted-variable">3.3. exec with restricted variable</h3>

<p>和 <em>eval</em> 一樣, <em>exec</em> 也可以用 <em>dict</em> 來限制可以使用的 <em>variable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>pb1 = 123
pb2 = [12,13,14]
pr1 = 456
pblist = [‘pb1’,’pb2’]
pbdict = dict([ (k, locals().get(k, None)) for k in pblist ])
print pbdict
{‘pb1’: 123, ‘pb2’: [12, 13, 14]}</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>同時, <em>exec</em> 又可以使用 <em>assignment</em>, 但是要注意了, 此 <em>assignment</em> 只會修改到 <em>dict</em> 中的值, 例如我們 <em>assign</em> 一個新的值給 <code>pb1</code></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(“pb1=pb1+2”, None, pbdict)
exec(“print pb1”, None, pbdict)
125</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>但是, <em>exec</em> 不會更改到原本的 <em>variable</em> 的值, 原本的 <code>pb1</code> 還是不便</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print pb1
123</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>改變的只有在 <code>pdict</code> 中的 <code>pb1</code></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print pbdict[‘pb1’]
125</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>但如果是針對 <em>object</em> 就不一樣了, 因為在 <em>dict</em> 中的是 <em>reference</em> 而不是 <em>value</em> , 所以會修改到原本 <em>variable</em> 的 <em>value</em>, 例如 <em>assign</em> 新的值給 <code>pb2</code></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(“pb2[2]=pb2[2]+3”, None, pbdict)
print pb2
[12, 13, 17]</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print pbdict[‘pb2’]
[12, 13, 17]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>不論是原本的 <code>pb2</code> 還是 <code>pbdict</code> 中的 <code>pb2</code> 都改變了</p>

<p>當然, 跟 <em>eval</em> 一樣的是, 如果 <em>variable</em> 沒在 <em>dict</em> 中, 就不可以使用了</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(“print pr1+3”, None, pbdict)
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
NameError: name 'pr1' is not defined</module></string></module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h3 id="exec-with-exec-defined-variable">3.4. exec with exec-defined variable</h3>

<p>承上, <em>exec</em> 由於有 <em>assignment</em> 的功能, 所以可以自己加 <em>variable</em> 到 <em>dict</em> 裏面, 如下, 我們限制 <em>exec</em> 從一個空的 <em>dict</em>  <code>pbdict2={}</code> 開始 </p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>pbdict2={}
exec(“x=5”, None, pbdict2)
exec(“y=3”, None, pbdict2)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>做完以上 <em>assignment</em> 之後 , 我們再把 <code>pbdict</code> 印出來看看, 發現多了兩個新的 <em>variable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print pbdict2
{‘y’: 3, ‘x’: 5}</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>當然, <em>exec</em> 可以用這兩個 <em>variable</em> 做運算</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(“print x+y”, None, pbdict2)
8</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h3 id="exec-lines-of-codes">3.5. exec lines of codes</h3>

<p><em>exec</em> 可以執行多行字串中的程式碼, 如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>codes=”””
… x=5
… for i in range(3):
…     x+=i
…     print i,x
… “””</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>exec(codes)
0 5
1 6
2 8</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="reference">4. Reference</h2>

<h3 id="eval-1">eval</h3>

<p>https://docs.python.org/2/library/functions.html#eval</p>

<h3 id="exec-1">exec</h3>

<p>https://docs.python.org/2/reference/simple_stmts.html#exec</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Nltk -- Logic 4 : Model and Satisfiability]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/03/29/python-nltk-logic-4/"/>
    <updated>2014-03-29T15:39:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/03/29/python-nltk-logic-4</id>
    <content type="html"><![CDATA[<h2 id="model-and-satisfiability">1.Model and Satisfiability</h2>

<p>可滿足性(Satisfiability)是在探討, 邏輯式子所建立出的模型(Model),</p>

<p>可不可以找到一組解, 使得這個 <em>Model</em> 算出來的值可以是 <script type="math/tex">True</script></p>

<p>例如：</p>

<script type="math/tex; mode=display">

p1=(x \vee y), \mspace{5mu}

p2=(\neg x \vee y),  \mspace{5mu}

p3=(x \vee \neg y) \\

M1=p1 \wedge p2 \wedge p3

</script>

<p>則當 <script type="math/tex">x\equiv True, \mspace{5mu} y \equiv  True</script> 時, <script type="math/tex">M1 \equiv True </script></p>

<p>則 <em>Model</em> <script type="math/tex">M1</script> 是 <em>Satisfiable</em></p>

<p>另一例子：</p>

<script type="math/tex; mode=display">

p1=(x \vee y), \mspace{5mu}

p2=(\neg x \vee y),  \mspace{5mu}

p3=(x \vee \neg y) \mspace{5mu}

p4=(\neg x \vee \neg y)\\

M2=p1 \wedge p2 \wedge p3 \wedge p4

</script>

<p>這種情形,不論 <script type="math/tex">x</script> 或 <script type="math/tex">y</script> 的值,  <script type="math/tex">M2</script> 永遠都是 <script type="math/tex">False</script></p>

<p>則 <em>Model</em> <script type="math/tex">M2</script> 是 <em>Unsatisfiable</em></p>

<!--more-->

<h2 id="implementation-1">2.Implementation 1</h2>

<p>接著我們用nltk來做簡單的 <em>Satisfiability</em> 問題</p>

<p>先載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk
lgp = nltk.LogicParser()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著,輸入邏輯式子<script type="math/tex">p1=(x \vee y), \mspace{5mu} p2=(\neg x \vee y),  \mspace{5mu}p3=(x \vee \neg y) \mspace{5mu}</script></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <table>
        <tbody>
          <tr>
            <td>p1 = lgp.parse(‘x</td>
            <td>y’)</td>
          </tr>
          <tr>
            <td>p2 = lgp.parse(‘-x</td>
            <td>y’)</td>
          </tr>
          <tr>
            <td>p3 = lgp.parse(‘x</td>
            <td>-y’)</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>然後把assignment加進去, 看看 <script type="math/tex">M1=p1 \wedge p2 \wedge p3</script> 是否 <em>satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>val = nltk.Valuation([(‘x’, True), (‘y’, True)])
dom = val.domain
g = nltk.Assignment(dom)
m = nltk.Model(dom, val)
m.satisfy(p1 &amp; p2 &amp; p3, g ) 
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再把 <script type="math/tex">p4=(\neg x \vee \neg y)</script> 加進去, 看看<script type="math/tex">M2=p1 \wedge p2 \wedge p3 \wedge p4</script> 是否 <em>satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>p4 = lgp.parse(‘-x | -y’)
m.satisfy(p1 &amp; p2 &amp; p3 &amp; p4, g ) 
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="first-order-logic">3. First Order Logic</h2>

<p>接著我們來看看如何將 <em>Model</em> 和 <em>Satisfiability</em> 的概念, 推廣到一階邏輯(First Order Logic)中</p>

<p>例如,在某個世界裡,</p>

<p><em>Gary</em> 是個男生, <em>Judy</em> 是個女生, 而 <em>Henry</em> 是一隻狗,</p>

<p><em>Gary</em> 和 <em>Henry</em> 在跑步, </p>

<p><em>Judy</em> 看見 <em>Henry</em> 而 <em>Gary</em> 看見 <em>Judy</em></p>

<p>我們可以用一階邏輯(First Order Logic)把這個世界表示成一個 <em>Model</em>：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&M=\\

& Gary(g)  &\wedge \mspace{15mu} & Judy(j)  &\wedge \mspace{15mu} &Henry(h) &\wedge\\

& Boy(g)   &\wedge \mspace{15mu} & Girl(j)  &\wedge \mspace{15mu} &Dog(h)   &\wedge\\

& Run(g)   &\wedge \mspace{15mu} & Run(h)   &\wedge \mspace{15mu} & & \\

& See(j,h) &\wedge \mspace{15mu} & See(g,j) &\wedge \mspace{15mu} &See(g,h)

\end{align}

 %]]&gt;</script>

<p>根據這個Model, 用<em>Satisfiability</em>的概念, 可以求解以下問題</p>

<p>1 . 找找看這個世界中女生有哪些</p>

<p>這個問題可以看成是, 從找 <em>M</em> 中找出滿足 <script type="math/tex">girl(x)</script> 的 <script type="math/tex">x</script> 值有哪些, </p>

<p>可求解 <script type="math/tex">girl(x) \wedge M </script> 的 <em>Satisfiability</em> , 得出：</p>

<p>女生有 <em>Judy</em> , 因為當 <script type="math/tex">x=j</script> 時, <script type="math/tex">girl(x) \wedge M </script> 為 <em>Satisfiable</em></p>

<p>2 . 回答這個世界中是否有男生在跑步, 或者, 是否有女生在跑步</p>

<p>這可以看成是, 判斷某個 formula 和這個 <em>M</em> 是否有交集, 得出：</p>

<p>有男生在跑步, 因為 <script type="math/tex">\exists x(Run(x) \wedge boy(x) ) </script> 在 <script type="math/tex"> M </script> 中為 <em>Satisfiable</em></p>

<p>沒有女生在跑步, 因為 <script type="math/tex">\exists x(Run(x) \wedge girl(x) ) </script> 在 <script type="math/tex"> M </script> 中為 <em>Unsatisfiable</em></p>

<p>3 . 回答是否 <em>Judy</em> 看見 <em>Henry</em> , 或者,是否 <em>Judy</em> 看見 <em>Gary</em></p>

<p>可以判斷某個assignment 是否可讓 <em>M</em> 為 <em>Satisfiable</em> , 得出：</p>

<p><em>Judy</em> 看見 <em>Henry</em> , 因為當 <script type="math/tex">x=j,y=h</script> 時, <script type="math/tex">See(x,y) </script> 在 <script type="math/tex">M </script> 中為 <em>Satisfiable</em></p>

<p><em>Judy</em> 沒有看見 <em>Gary</em> , 因為當<script type="math/tex">x=j,y=g</script> 時, <script type="math/tex">See(x,y) </script> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<p>註：</p>

<p>1.在 python nltk 用的是 <em>Closed World Assumption</em> </p>

<p>也就是說, 在 <em>Model</em> 裡面沒有定義的, 一律為 <em>False</em></p>

<p>例如沒有定義 <em>Run(j)</em> , 所以 <em>Run(j)</em> 為 <em>False</em> </p>

<p>因此 <script type="math/tex">\exists x(Run(x) \wedge girl(x) ) </script> 在 <script type="math/tex"> M </script> 中為 <em>Unsatisfiable</em> </p>

<p>同理, <em>See(j,g)</em> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<p>2.相對於 <em>Closed World Assumption</em> </p>

<p>有另一種叫作 <em>Open World Assumption</em> </p>

<p>是將沒有定義的formula 它視為 <em>Unknown</em></p>

<p>所以結果除了 <em>True</em> 和 <em>False</em> 之外, 還有 <em>Unknown</em></p>

<h2 id="implementation-2">4.Implementation 2</h2>

<p>用 python nltk 來實作看看：</p>

<p>首先, 建立 model</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>v = “”” 
… Gary =&gt; g
… Judy =&gt; j
… Henry =&gt; h
… boy =&gt; {g}
… girl =&gt; {j}
… dog =&gt; {h}
… run =&gt; {g, h}
… see =&gt; {(j, h), (g, j), (g, h)}
… “””</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>val = nltk.parse_valuation(v)
m = nltk.Model(val.domain, val)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>1.求 <script type="math/tex">girl(x)</script> 的 <script type="math/tex">x</script> 值:</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfiers(lgp.parse(‘girl(x)’), ‘x’  , nltk.Assignment(val.domain, []))
set([‘j’])</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>得出結果 <script type="math/tex">x=j</script></p>

<p>2.求 <script type="math/tex">\exists x (Run(x) \wedge boy(x)) </script> 或 <script type="math/tex">\exists x (Run(x) \wedge girl(x))</script> 這兩個formula在 <script type="math/tex">M</script> 中是否為 <em>Satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘exists x.(run(x) &amp; boy(x))’),nltk.Assignment(val.domain, []))
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘exists x.(run(x) &amp; girl(x))’),nltk.Assignment(val.domain, []))
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>得出結果：</p>

<p><script type="math/tex">\exists x(Run(x) \wedge boy(x) )</script> 在 <script type="math/tex">M </script> 中為 <em>Satisfiable</em></p>

<p><script type="math/tex">\exists x(Run(x) \wedge girl(x) ) </script> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<p>3.求 <script type="math/tex">x=j,y=h</script> 或 <script type="math/tex">x=j,y=g</script> 對於 <script type="math/tex">See(x,y)</script> 在 <script type="math/tex">M</script> 中是否為 <em>Satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘see(x,y)’),nltk.Assignment(val.domain,[(‘x’, ‘j’), (‘y’, ‘h’)]))
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘see(x,y)’),nltk.Assignment(val.domain,[(‘x’, ‘j’), (‘y’, ‘g’)]))
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>得出結果：</p>

<p>當 <script type="math/tex">x=j,y=h</script> 時, <script type="math/tex">See(x,y) </script> 在 <script type="math/tex">M </script> 中為 <em>Satisfiable</em></p>

<p>當<script type="math/tex">x=j,y=g</script> 時, <script type="math/tex">See(x,y)</script> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<h2 id="reference">5.Reference</h2>

<p>關於python nltk的 <em>model</em> 和 <em>satistiability</em> 可參考：</p>

<p>http://nltk.googlecode.com/svn/trunk/doc/book/ch10.html</p>

<p>關於 <em>Closed World Assumption</em> 與 <em>Open World Assumption</em> 可參考：</p>

<p>http://en.wikipedia.org/wiki/Closed_world_assumption</p>

<p>http://en.wikipedia.org/wiki/Open_world_assumption</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Nltk -- Logic 3 : Discourse Representation Theory]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/03/21/python-nltk-logic-3/"/>
    <updated>2014-03-21T03:58:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/03/21/python-nltk-logic-3</id>
    <content type="html"><![CDATA[<h2 id="introduction">1. Introduction</h2>

<p><em>Discourse</em> 的意思是對話</p>

<p>在對話中,常常會用到 <strong>代名詞</strong> ,像是 <em>he</em>, <em>she</em> 或 <em>it</em>.</p>

<p>我們把這種代名詞叫做 <em>anaphoric pronouns</em></p>

<p>因為要從前面的句子去判斷,這些代名詞代表什麼</p>

<p>比如有個句子 <em>A woman walks. She smokes.</em></p>

<p>在下一句的 <em>She</em> 是指前一句提到的 <em>A woman</em></p>

<p>那要怎麼讓電腦去判斷, <strong>代名詞</strong> 到底代表前面提到的什麼？</p>

<p>這就要用到 <em>Discourse Representation Theory (DRT)</em> 來處理了</p>

<p>例如 <em>A woman walks</em> 這句話,用 <em>DRT</em> 可以表示成這樣：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline x  \\ \hline

    	woman(x) \\

      walk(x) \\

    \hline

		\end{array}

</script>

<!--more-->

<p>這樣一個框框的結構叫作 <em>Discourse Representation Structure</em> ,簡稱 <em>DRS</em></p>

<p>其中位於方框上面的 <script type="math/tex">x</script> 叫做 <em>Discourse Referent</em> </p>

<p>它代表這個句子中,可以被其他代名詞參考的東西</p>

<p>方框下方的式子叫做 <em>DRS conditions</em> </p>

<p>它代表這些文句所產生的情境</p>

<p>第二個句子 <em>She smokes.</em></p>

<p>用 <em>DRT</em> 表示成這樣：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline y  \\ \hline

      PRO(y) \\

      smoke(y) \\

    \hline

		\end{array}

</script>

<p>其中, <script type="math/tex">PRO(y)</script> 表示 <script type="math/tex">y</script> 是一個代名詞,但不知道它代表誰</p>

<p>這個時候就要用 <em>DRT</em> ,把對話中前後語句的情境結合起來</p>

<p>就可以進行 <em>Resolve Anaphora</em> 找出代名詞代表什麼</p>

<p>例如：</p>

<p><em>A woman walks. She smokes.</em></p>

<p>用 <em>DRT</em> 表示成：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline x  \\ \hline

    	woman(x) \\

      walk(x) \\

    \hline

		\end{array}

    +

    \begin{array}{|c|}

    \hline y  \\ \hline

      PRO(y) \\

      smoke(y) \\

    \hline

		\end{array}

    \xrightarrow{Simplify}

    \begin{array}{|c|}

    \hline x,y  \\ \hline

    	woman(x) \\

      walk(x) \\

      PRO(y) \\

      smoke(y) \\

    \hline

		\end{array}

    \xrightarrow{Resolve\mspace{5mu} Anaphora}

    \begin{array}{|c|}

    \hline x,y  \\ \hline

    	woman(x) \\

      walk(x) \\

      x = y \\

      smoke(y) \\

    \hline

		\end{array}

</script>

<p>藉由 <em>DRT</em> ,我們可以知道 <em>She</em> 是指 <em>A woman</em></p>

<p>然後,還可以把 <em>DRS</em> 轉成一階邏輯的式子：</p>

<p>像這樣：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline x,y  \\ \hline

    	woman(x) \\

      walk(x) \\

      x = y \\

      smoke(y) \\

    \hline

		\end{array}

    \Rightarrow

    \exists x \exists y.( woman(x) \wedge walk(x) \wedge (x = y) \wedge smoke(y))

</script>

<h2 id="drt-in-nltk">2. DRT in nltk</h2>

<p>現在我們來用nltk實作看看</p>

<p>先載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著我們輸入 <em>A woman walks</em> 的 <em>DRT</em> </p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>dp = nltk.DrtParser()
drs1 = dp.parse(‘([x], [woman(x), walk(x)])’) 
print drs1
([x],[woman(x), walk(x)])</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>我們也可以把 <em>DRT</em> 的結構畫出來</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs1.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>像這樣</p>

<p><img src="http://lh6.googleusercontent.com/-89PLq9VYopQ/UyvQx-TxTfI/AAAAAAAAAqY/cU232E7UWKQ/s165-no/DRT.png" /></p>

<p>接著我們把第二句話 <em>She smokes.</em> 也一起輸入</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs2 = dp.parse(‘([y], [PRO(y),smokes(y)])’) 
drs2.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh3.googleusercontent.com/-ugJ-AhsCo28/Uyva__Uz4QI/AAAAAAAAAqw/wgYKB9yYOcI/w163-h165-no/DRT2.png" /></p>

<p>其中 <code>PRO(y)</code> 是未知的代名詞,</p>

<p>因為只看這句話不知道這個代名詞代表什麼, </p>

<p>需要和第一句話結合起來才知道</p>

<p>我們可以用 <code>+</code> 把這 <em>兩個DRS</em> 合起來</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs3=drs1+drs2
drs3.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh6.googleusercontent.com/-ZVVEazh0bxU/Uyva_xl9HZI/AAAAAAAAArE/FOh2NjrkihE/w335-h158-no/DRT3.png" /></p>

<p>再用 <code>simplify()</code> 把這兩個 <em>DRS</em> 簡化成一個</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs4=drs3.simplify()
drs4.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh6.googleusercontent.com/-XS97Rkd11iM/Uyva_tAb7oI/AAAAAAAAArU/ga7l4KP5QV4/w165-h240-no/DRT4.png" /></p>

<p>然後再用 <code>resolve_anaphora()</code> 找出代名詞 <code>PRO(y)</code> 代表什麼</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs5=drs4.resolve_anaphora()
drs5.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh6.googleusercontent.com/-xqOOLlm0h7w/UyvbAKBA7RI/AAAAAAAAAq8/KOkSJP2nJG4/w168-h240-no/DRT5.png" /></p>

<p>這時,原本的 <code>PRO(y)</code>  會變成 <code>(y = x)</code> 表示已經找出了 <code>y</code> 代表什麼</p>

<p>然後, 還可以把 <em>DRS</em> 轉成 <em>First-order Logic</em> 的式子</p>

<p>像這樣：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>f1=drs5.fol()
print f1
exists x y.(woman(x) &amp; walks(x) &amp; (y = x) &amp; smokes(y))</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣就大功告成了</p>

<h2 id="further-reading">3.Further Reading</h2>

<p>其實 <em>DRT</em> 還可以解決許多關於對話中的語意問題</p>

<p>有興趣的話可以看這個網站：Discourse Representation Theory </p>

<p>http://www.coli.uni-saarland.de/projects/milca/courses/comsem/html/node205.html</p>

<p>以及這本書：</p>

<p><em>Hans Kamp, Josef van Genabith, Uwe Reyle. Discourse Representation Theory</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python -- Functional Programming Style 2]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/03/20/python-functional-programming-style-2/"/>
    <updated>2014-03-20T13:35:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/03/20/python-functional-programming-style-2</id>
    <content type="html"><![CDATA[<p>用Functional Programming style來寫程式的時候</p>

<p>可以大幅減少行數和變數的數量</p>

<p>本文接續上一篇:/blog/2014/03/18/python-functional-programming-style-1</p>

<p>繼續探討這種Functional Programming style在python中的應用</p>

<h2 id="operator">1. operator</h2>

<p>首先,載入 <code>operator</code> 這個模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import operator</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>然後,來介紹到底要怎麼使用</p>

<!--more-->

<h4 id="operatoradd-operatormultiply-etc">1.1, operator.add, operator.multiply, etc</h4>

<p><code>operator</code> 是一個提供加減乘除之類運算的module,</p>

<p>有的時候不太方便直接用到 <code>+</code> , <code>-</code> 這些符號,</p>

<p>這時候就要用到 <code>operator</code> 這個模組了</p>

<p>如果要求一個list中所有元素的總和,如果不會functional programming style</p>

<p>最基本的寫法,用for迴圈寫,如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>s=0
for i in [3,5,7,9,11]:
…     s += i </p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print s
35</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣要寫很多行</p>

<p>可以用lambda function簡化</p>

<p>```python </p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>reduce(lambda a,b:a+b,[3,5,7,9,11])
35</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>但其實可以連lambda function都不用寫</p>

<p>因為python就已經有內建好這些function</p>

<p>我們可以用 <code>operator.add</code> 搭配 <code>reduce</code> 就可以了</p>

<p>```python </p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>reduce(operator.add,[3,5,7,9,11])
35</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這就是 <code>operator</code> 的用法,可以把＋,-,之類的operator運算當成function來使用</p>

<p>事實上,根本什麼都不用寫,用內建的function <code>sum()</code> 就可以了</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>sum([3,5,7,9,11])
35</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>本文是為了教Functional Programming style舉出operator和reduce搭配使用</p>

<p>讓讀者懂得如何用這些功能</p>

<p>再舉一例,如果有兩向量<script type="math/tex">V_{1},V_{2}</script> </p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>V1 = [2,3,4]
V2 = [5,-2,3]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>求兩向量內積 <script type="math/tex">v_{11}v_{21}+v_{12}v_{22}+v_{13}v_{23}</script></p>

<p>可以用 <code>operator.add</code> 和 <code>operator.mul</code> ,如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>reduce(operator.add,map(operator.mul, V1,V2))
16</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h4 id="operatoritemgetter">1.2 operator.itemgetter</h4>

<p>在運算符號中, <code>operator.itemgetter</code> 相對於運算符號的 <code>[]</code>, </p>

<p>可以取出list 或dict 中的element</p>

<p>但有些情形 <code>operator.itemgetter</code> 會比較方便</p>

<p>給定一個list</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>my_list = [1,2,1,3,4,6]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>假如要取出某個list中index為1者</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>operator.itemgetter(1)(my_list)
2</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣還是直接用 <code>[]</code> 比較快</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>my_list[1]
2</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>但是如果要取出index為1,3,5的三個element</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>my_list[1],my_list[3],my_list[5]
(2, 3, 6)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣有點麻煩了,來用 <code>operator.itemgetter</code> 看看</p>

<p>```</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>operator.itemgetter(1,3,5)(my_list)
(2, 3, 6)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>用, <code>operator.itemgetter</code> 就比較快了</p>

<p>至於還有哪些情況會用到 <code>operator.itemgetter</code> ?</p>

<p>例如在計算語言學的研究中,用freqdist計算每個單字在文章中出現的頻率,</p>

<p>如下, <em>is</em> 出現了193次,之類的</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>freqdist=[(‘a’, 185), (‘is’, 93), (‘the’, 219), (‘he’,51)]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>如果要取出每個單字的出現頻率,可以用 <code>itemgetter</code> 搭配 <code>map</code> 使用</p>

<p>如果把單字依出現頻率高低排序,可以用 <code>itemgetter</code> 搭配 <code>sorted</code> 使用</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>map(operator.itemgetter(1),freqdist)
[185, 93, 219, 51]</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>sorted(freqdist, key=operator.itemgetter(1),reverse=True)
[(‘the’, 219), (‘a’, 185), (‘is’, 93), (‘he’, 51)]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h4 id="operatormethodcaller">1.3 operator.methodcaller</h4>

<p>如果遇到一種情況,要根據某個variable的值,來判斷要call哪個function</p>

<p>假設有個class有兩個function,如下:</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>class CallerDemo():
…     def print_a(self):
…         print ‘a’
…     def print_b(self):
…         print ‘b’
… </p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>然後根據variable <code>x</code> 來判斷要call <code>print_a()</code> or <code>print_b()</code> </p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>def my_print(x):
…     if x == ‘a’:
…         CallerDemo().print_a()
…     elif x == ‘b’:
…         CallerDemo().print_b()
… </p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>執行結果如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>my_print(‘a’)
a</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>my_print(‘b’)
b</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣寫真的頗麻煩的,</p>

<p>這個時候可以用 <code>operator.methodcaller</code>, 根據字串名稱,選擇要call哪個function</p>

<p>例如:</p>

<p>```</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>{‘1’:11,’2’:22}.keys()
[‘1’, ‘2’]</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>operator.methodcaller(‘keys’)({‘1’:11,’2’:22})
[‘1’, ‘2’]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>用了 <code>operator.methodcaller</code> ,改寫之前的 <code>my_print(x)</code> ,一行就夠了</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>def my_caller_print(x):
…     operator.methodcaller(“print_%s”%(x))(CallerDemo())</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>執行結果如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>my_caller_print(‘a’)
a</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>my_caller_print(‘b’)
b</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="functoolspartial">2 functools.partial</h2>

<p>functools 是一些針對higher-order function的一個模組</p>

<p>這些higher-order function可以把其他function當成argument</p>

<p>先載入一下模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import functools</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>我們先來介紹一下 <code>functools.partial</code> 的功能</p>

<p>假設現在要保留某個list之中等於1的element,</p>

<p>可以用到先前提到的 <code>operator</code> 模組,的 <code>operator.eq(a,b)</code> 來比較大小</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>x=1
operator.eq(1,x)
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>如果要搭配 <code>filter</code> 使用,來去掉list中不等於1的element,該怎麼辦呢？</p>

<p>因為 <code>operator.eq(a,b)</code> 需要兩個argument, </p>

<p>但 <code>filter</code> 只能接受一個function與另一個argument</p>

<p>如果要輸入 <code>eq(a,b)</code> 所需要的兩個argument,會出現error,如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>filter(operator.eq,1,[1,2,3,1,1,2,2,1,3])
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
TypeError: filter expected 2 arguments, got 3</module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這個時候,就需要用到 <code>functools.partial</code> 了</p>

<p>它可以先把 <code>operator.eq(a,b)</code> 先和其中一個argument做結合,包成一個function</p>

<p>使用方法如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eq1=functools.partial(operator.eq,1)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣產生出來的function, <code>eq1</code> 就只需要一個argument了</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eq1(1)
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>eq1(2)
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>

    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>也就是說,可以把它放到 <code>filter</code> 裡面使用了</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>filter(eq1,[1,2,3,1,1,2,2,1,3])
[1, 1, 1, 1]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再舉一個例子,</p>

<p>如果要十六進位的數轉成十進位,可以用 <code>int()</code> 這個function</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>int(“ABCDEF”,base = 16)
11259375</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>int(“AAAAAA”,base = 16)
11184810</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣每次都要輸入兩個argument,而且第二個argument要一直重複輸入,比較麻煩</p>

<p>可以用 <code>functool.partial</code> 先把int和第二個argument包成一個,如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>base16 = functools.partial(int, base=16)
base16(“ABCDEF”)
11259375</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>base16(“AAAAAA”)
11184810</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣子看起來就簡潔多了</p>

<h2 id="further-reading">Further Reading:</h2>

<p>其實 <code>functool</code> 還有一個很好用的function: <code>functool.wraps</code></p>

<p>但這個跟 <em>Design Pattern</em> 的 <em>decorator</em> 有關</p>

<p>等之後有機會提到 <em>Design Pattern</em> 的時候再來講解</p>

<p>關於本文所講到的,想知道更多,請看：</p>

<p>operator: http://docs.python.org/2/library/operator.html</p>

<p>functools: http://docs.python.org/2/library/functools.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Nltk -- Logic 2 : Lambda Calculus]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/03/13/python-nltk-logic-2/"/>
    <updated>2014-03-13T14:09:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/03/13/python-nltk-logic-2</id>
    <content type="html"><![CDATA[<p>本篇介紹如何用python nltk 的應用,邏輯語意與lambda calculus</p>

<h2 id="introduction">1.introduction</h2>

<p>邏輯語意學在語意推導方面,通常會用到 <script type="math/tex">\lambda -calculus</script></p>

<p>使用<script type="math/tex">\lambda -calculus</script>就可以把一個句子的語意,從個別單字中推導出來</p>

<p>至於<script type="math/tex">\lambda -calculus</script> 是什麼呢？</p>

<p>簡而言之,lambda calculus是一種數學運算,由以下三種元素組成</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}


& v  & (a)\\

& \lambda x.f(x)  & (b)\\

& \lambda x.f(x)(v) & (c)\\


\end{align}

 %]]&gt;</script>

<p><script type="math/tex">(a)</script> 是 <script type="math/tex">variable</script></p>

<p><script type="math/tex">(b)</script> 是 <script type="math/tex">astraction</script> ,就是把function中的variable拿到前面,加個 <script type="math/tex">\lambda</script></p>

<p><script type="math/tex">(c)</script> 是將另一個 <script type="math/tex">variable</script> 放到 <script type="math/tex">astraction</script> 後面</p>

<p>然後可以進行一種運算,叫做 <script type="math/tex">\beta-reduction</script> ,如下</p>

<script type="math/tex; mode=display">

\lambda x.f(x)(v)

\Rightarrow f(v)

</script>

<p>還有另一種運算叫做 <script type="math/tex">\alpha-conversion</script> ,其實就是更改變數名稱而已</p>

<script type="math/tex; mode=display">

\lambda x.f(x)

\Rightarrow \lambda y.f(y)

</script>

<!--more-->

<p><script type="math/tex">\lambda -calculus</script> 也是計算理論的一種,和Turing Machine等價</p>

<p>實際上以 <script type="math/tex">\lambda -calculus</script> 實現的程式語言有Functional Programming,例如Lisp或Haskell</p>

<h2 id="lambda-expression">2. lambda expression</h2>

<p>接著來實作untyped lambda calculus,</p>

<p>首先,載入模組 <code>nltk.sem.logic</code> 和 <code>LogicParser</code></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk.sem.logic as logic
lgp = logic.LogicParser()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再看看 <script type="math/tex">\lambda</script> 要用哪個符號</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>logic.binding_ops()
existential    	exists
universal      	all
lambda         	\</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>要表示lambda <script type="math/tex">\lambda</script> 符號,要用 <code>\</code> 字串</p>

<p>然後,用<code>LogicParser</code>來輸入這個式子：<script type="math/tex">e1=\lambda x.P(x)</script></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e1 = lgp.parse(r’\x.P(x)’)
print e1
\x.P(x)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="alpha-conversion">3. alpha conversion</h2>

<p>再來試試看<script type="math/tex">\alpha-conversion</script> : <script type="math/tex">\exists x.P(x) \Rightarrow \exists z.P(z)</script></p>

<p>從以下結果得知,<script type="math/tex">\alpha-conversion</script> 轉換前和轉換後,在邏輯上是相等</p>

<p>因為只是更改變數名稱而已</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e2 = e1.alpha_convert(logic.Variable(‘z’))
print e2
\z.P(z)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e1 == e2
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="beta-reduction">4. beta reduction</h2>

<p>接著,來看看 <script type="math/tex">\beta-reduction</script> </p>

<p>舉一個自然語言的例子,例如 <em>Gary walks.</em> 這個句子,用邏輯語意可以表示成</p>

<script type="math/tex; mode=display">

walks(Gary)

</script>

<p>根據Principle of Compositionality,</p>

<p>句子的語意是由單字的語意所組成的(但實際上還是有例外,例如片語)</p>

<p>推導出這個句子的語意,可由單字的語意推導出來,</p>

<p><em>walks</em> 的語意是 <script type="math/tex">\lambda x.walk(x)</script></p>

<p><em>Gary</em> 的語意是 <script type="math/tex">Gary</script></p>

<p>則 <em>Gary walks</em> 的語意是</p>

<script type="math/tex; mode=display">

\lambda x.walks(x) (Gary)\Rightarrow walks(Gary)

</script>

<p>接著來實作看看</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e3 = lgp.parse(r’\x.walks(x)(Gary)’)
e4 = e3.simplify()
print e4
walks(Gary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再舉一個例子,例如 <em>Gary sees Mary.</em> 這個句子, <em>sees</em> 是及物動詞</p>

<p>及物動詞,是表示一個主詞和受詞的關係,</p>

<p>可用 <em>First Order Logic</em> 的 <em>Relation</em> 來表示</p>

<p><em>sees</em> 的語意為 <script type="math/tex">\lambda x \lambda y .see(x,y)</script></p>

<p>而 <em>Gary sees Mary.</em> 的語意是</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

& \lambda x \lambda y.see(x,y) (Gary) (Mary) \\

& \Rightarrow \lambda y(Gary,y) (Mary) \\

& \Rightarrow see(Gary,Mary)

\end{align}

 %]]&gt;</script>

<p>接著,輸入nltk看看</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e5 = lgp.parse(r’\x \y.see(x,y)(Gary)(Mary)’)
print e5
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e5.simplify()
see(Gary,Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>還有其他的輸入方式,結果都一樣</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e6 = lgp.parse(r’\x \y.see(x,y)(Gary,Mary)’)
e7 = lgp.parse(r’\x y.see(x,y)(Gary,Mary)’)
e8 = lgp.parse(r’\x y.see(x,y)(Gary)(Mary)’)
e9 = lgp.parse(r’(\x y.see(x,y)(Gary))(Mary)’)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>結果如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e6
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e7
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e8
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e9
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e6 == e7 == e8 == e5
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="further-reading">5.further reading</h2>

<p>想要瞭解 <script type="math/tex">\lambda -calculus</script>, 請參考http://en.wikipedia.org/wiki/Lambda_calculus</p>

<p>想要看看 nltk 裡面的 <script type="math/tex">\lambda -calculus</script> , 請至http://www.nltk.org/howto/logic.html</p>

<p>還有關於邏輯語意的研究,可以參考這本書 <em>Blackburn &amp; Bos’  Representation and Inference for Natural Language</em></p>
]]></content>
  </entry>
  
</feed>
