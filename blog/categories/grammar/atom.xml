<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Grammar | Mark Chang's Blog]]></title>
  <link href="http://ckmarkoh.github.io/blog/categories/grammar/atom.xml" rel="self"/>
  <link href="http://ckmarkoh.github.io/"/>
  <updated>2016-12-10T22:36:39+08:00</updated>
  <id>http://ckmarkoh.github.io/</id>
  <author>
    <name><![CDATA[Mark Chang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Nltk -- Dependency Grammar]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/05/03/python-nltk-dependency-grammar/"/>
    <updated>2014-05-03T15:00:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/05/03/python-nltk-dependency-grammar</id>
    <content type="html"><![CDATA[<h2 id="introduction">1. Introduction</h2>

<p>在自然語言處理中, <em>Phase-Structured Grammar</em> 這類的文法, 是把一個句子, 剖析成一個 <strong>完整的剖析樹</strong> , 它的重點是句子中各個成份的階層關係, 例如 <em>Context-Free Grammar</em></p>

<p>而所謂的 <em>Dependenct Grammar</em> , 是著重在 <strong>字和字之間關係</strong> , 而非整個句子中各種成份階層關係, 例如 </p>

<script type="math/tex; mode=display">

\text{I shot an elephant in my pajamas.}

</script>

<p>用<em>Depedenct Grammar</em> 可以表示成這樣</p>

<p><img src="/images/pic/pic_00067.png" alt="d0" /></p>

<p>如上圖, 把詞語和詞語之間的關係, 用箭頭表示, 箭頭的起點為 <em>Head</em>, 終點為 <em>dependents</em> , 標示箭頭上的英文字代表 <em>Head</em> 和 <em>Dependent</em> 之間的 <em>relation</em></p>

<!--more-->

<p><em>Head</em> 的意思是中心語, 就是比較重要的概念, 而 <em>Dependent</em> 則是用來修飾這個概念的詞語 , 例如 <em>an elephant</em> 這一小片段中, 重要的概念為 <em>elephant</em> , 而 <em>an</em> 是 <em>elephant</em> 的修飾語</p>

<p>通常會在句子中挑一個最重要的中心語, 通常是動詞, 當作 <em>ROOT</em> , 如上圖例子的 <em>ROOT</em> 為 <em>shot</em>, 而 <em>shot</em> 的 <em>Dependent</em> 有 <em>I</em> 和 <em>elephant</em> , 它們和 <em>shot</em> 之間的 <em>relation</em> 分別為 <em>SBJ</em> 和 <em>OBJ</em> , 以此類推</p>

<p>相較於 <em>Phase-Structured Grammar</em> 需要整個句子都文法正確, 才可以得出剖析樹, 而 <em>Dependency Grammar</em> 不需要整個句子裡面的每個字都文法正確, 也可以得到剖析樹, 因為只需要注意字和字的關係即可</p>

<h2 id="dependencygraph">2. DependencyGraph</h2>

<p>在 <em>python nltk</em> 裡, 可以用 <code>DependencyGraph</code> 來載入 <em>Dependency Grammar</em></p>

<p>首先載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>from nltk.parse import DependencyGraph</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著用以下的 <em>string</em> 來表示前例的 <em>Dependency Grammar</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>dep_str= \
… “””
… I         NOUN  2    SBJ
… shot      VERB  0    ROOT 
… an        DET   4    DETMOD
… elephant  NOUN  2    OBJ
… in        PREP  4    NMOD
… my        DET   7    DETMOD
… pajamas   NOUN  5    PMOD
… “””</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>

    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>其中, 每行可分成四個部份, 第一部份是句子中的單字, 第二部份是這個單字的 <em>Part of Speech(POS) Tagging</em> , 第三和第四部份是它的 <em>Head</em> 的 <em>index</em> 以及 <em>relation</em>, 例如 <em>I</em> 這個字, 它的 <em>POS Tagging</em> 為 <em>Noun</em> , 它的 <em>Head</em> 為 <em>shot</em>, <em>Head</em> 的 <em>index</em> 為 <em>shot</em> 在句子中的位置, 為 <em>2</em>, 而 <em>relation</em> 為 <em>SBJ</em> , 以此類推, 見下圖</p>

<p><img src="/images/pic/pic_00068.png" alt="d1" /></p>

<p>上圖將每個字標上 <em>index</em> , 以方便建構出 <em>Dependency Graph</em></p>

<p>再來用 <code>DependencyGraph</code> 讀入這個 <code>dep_str</code></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>dg = DependencyGraph(dep_str) </p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>可以把 <em>Dependency Graph</em> 轉成 <em>Syntax Tree</em> 印出來</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>dg.tree().pprint()
‘(shot I (elephant an (in (pajamas my))))’</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>或者畫出來</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>dg.tree().draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>呈現如下圖</p>

<p><img src="/images/pic/pic_00070.png" alt="d2" /></p>

<p>由上圖可知, <em>Dependency Grammar</em> 所形成的 <em>syntax tree</em> , 和 <em>Phase-Structured Grammar</em> 最大的不同點在於, 每個 <em>Node</em> 是一個字, 而不是 <em>Non-Terminal</em> , <em>Node</em> 和 <em>Node</em> 之間的 <em>edge</em> 表示 <em>dependent relation</em> 而非 <em>production</em>. </p>

<h2 id="dependency-parsing">3. Dependency Parsing</h2>

<p>接著來談到如何把一個句子, 利用 <em>Dependency Grammar</em> 轉成 <em>Syntax Tree</em> 和 <em>Dependency Graph</em></p>

<p>先載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>from nltk import parse_dependency_grammar</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>還有尚未剖析的 <em>Raw Sentence</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>sent = ‘I shot an elephant in my pajamas’.split()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著是 <em>Grammar</em> 的部份, 箭號左邊為 <em>head</em> , 右邊為 <em>dependent</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>dep_grammar = parse_dependency_grammar(
… “””
… ‘shot’ -&gt; ‘I’ | ‘elephant’ | ‘in’
… ‘elephant’ -&gt; ‘an’ | ‘in’
… ‘in’ -&gt; ‘pajamas’
… ‘pajamas’ -&gt; ‘my’
… “””
… )</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>在 <code>nltk</code> 裡面, 提供兩種方式, 分別為 <em>Projective Dependency</em> 和 <em>Non-Projective Dependency</em></p>

<p>分別可以把 <em>Raw Sentence</em> 轉為 <em>Syntax Tree</em> 和 <em>Dependency Graph</em></p>

<h3 id="projective-dependency-parsing">3.1 Projective Dependency Parsing</h3>

<p><code>ProjectiveDependencyParser</code> 可將 <em>Raw Sentence</em> 轉為 <em>syntax tree</em></p>

<p>載入以下模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>from nltk import ProjectiveDependencyParser</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著用 <code>ProjectiveDependencyParser</code> 載入文法來剖析句子, 如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>trees = ProjectiveDependencyParser(dep_grammar).parse(sent)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>因為本例的文法為 <em>ambiguous grammar</em> , 也就是說, 可能的 <em>syntax tree</em> 超過一種以上</p>

<p>程式會求出所有可能的 <em>syntax tree</em> , 如本例, 有兩個可能的 <em>syntax tree</em> </p>

<p>```</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>trees[0].pprint()
‘(shot I (elephant an (in (pajamas my))))’</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>trees[1].pprint()
‘(shot I (elephant an) (in (pajamas my)))’</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>用以下方法畫出來</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>trees[0].draw()
trees[1].draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="/images/pic/pic_00070.png" alt="d2" /></p>

<p><img src="/images/pic/pic_00071.png" alt="d3" /></p>

<h3 id="non-projective-dependency-parsing">3.2 Non-Projective Dependency Parsing</h3>

<p><code>NonprojectiveDependencyParser</code> 可將 <em>Raw Sentence</em> 轉為 <em>dependency graph</em></p>

<p>載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>from nltk import NonprojectiveDependencyParser</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著用 <code>NonprojectiveDependencyParser</code> 載入文法來剖析句子, 如下</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>dep_graphs = NonprojectiveDependencyParser(dep_grammar).parse(sent)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>本例也會得出兩個可能的結果, 可以用 <code>print</code> 印出 <em>dependency graph</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print dep_graphs[0]
[{‘address’: 0, ‘deps’: 2, ‘rel’: ‘TOP’, ‘tag’: ‘TOP’, ‘word’: None},
 {‘address’: 1, ‘deps’: [], ‘word’: ‘I’},
 {‘address’: 2, ‘deps’: [1, 4], ‘word’: ‘shot’},
 {‘address’: 3, ‘deps’: [], ‘word’: ‘an’},
 {‘address’: 4, ‘deps’: [3, 5], ‘word’: ‘elephant’},
 {‘address’: 5, ‘deps’: [7], ‘word’: ‘in’},
 {‘address’: 6, ‘deps’: [], ‘word’: ‘my’},
 {‘address’: 7, ‘deps’: [6], ‘word’: ‘pajamas’}]</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print dep_graphs[1]
[{‘address’: 0, ‘deps’: 2, ‘rel’: ‘TOP’, ‘tag’: ‘TOP’, ‘word’: None},
 {‘address’: 1, ‘deps’: [], ‘word’: ‘I’},
 {‘address’: 2, ‘deps’: [1, 4, 5], ‘word’: ‘shot’},
 {‘address’: 3, ‘deps’: [], ‘word’: ‘an’},
 {‘address’: 4, ‘deps’: [3], ‘word’: ‘elephant’},
 {‘address’: 5, ‘deps’: [7], ‘word’: ‘in’},
 {‘address’: 6, ‘deps’: [], ‘word’: ‘my’},
 {‘address’: 7, ‘deps’: [6], ‘word’: ‘pajamas’}]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>其中 <code>address</code> 表示 <code>word</code> 的 <em>id</em> , <code>deps</code> 為這個 <code>word</code> 的 <em>dependent</em></p>

<p><em>註：事實上,  Non-Projective 和 Projective 最主要的差異在於, Non-Projective 可以處理字詞順序可任意顛倒的語言, 在處理這種語言時, 產生出的 Syntax Tree 由於字詞顛倒, 會有交叉, 故通常用 Dependency Graph 來表示結果, 本文不探討這種現象, 若你想了解, 請看以下的 Further Reading</em> </p>

<h2 id="furtuer-reading">Furtuer Reading</h2>

<p>想要了解更多關於 <em>Dependency Grammar</em> 可以看以下兩篇 <em>python nltk</em> 的 <em>Documentation</em></p>

<p>Python nltk HOWTO dependency</p>

<p>http://www.nltk.org/howto/dependency.html</p>

<p>Python nltk book ch08</p>

<p>http://nltk.googlecode.com/svn/trunk/doc/book/ch08.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Nltk -- Tree]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/02/28/python-nltk-tree/"/>
    <updated>2014-02-28T16:36:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/02/28/python-nltk-tree</id>
    <content type="html"><![CDATA[<p>今天我們來看看nltk.Tree要怎麼用</p>

<p>先載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>from nltk import Tree</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="build-syntax-tree">1.build syntax tree</h2>

<p>舉個例子</p>

<p>Gary plays baseball</p>

<p>此句子的剖析樹(syntax tree)是這樣：</p>

<p><img src="http://lh3.googleusercontent.com/-BoNaoH3Va-g/UyF3tY8MRiI/AAAAAAAAAXM/1-YLB7zww3k/w299-h238-no/nltk1.png" alt="nltk1.png" /></p>

<p>用nltk.Tree來建構tree：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree=Tree(‘S’,[Tree(‘NP’,[‘Gary’]),
…           Tree(‘VP’,[Tree(‘VT’,[‘plays’]),
…                     Tree(‘NP’,[‘baseball’])])])</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>即可將剖析樹畫出來</p>

<p>若沒安裝 python-tk,你也可以這樣把tree印出</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree.pprint()
‘(S (NP Gary) (VP (VT plays) (NP baseball)))’</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<!--more-->

<h2 id="subtrees-nodes-and-leaves">2. Subtrees ,Nodes and Leaves</h2>

<p>再來可以對tree進行操作</p>

<p>例如：取得tree的subtree, node 和leaf</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree[1]
Tree(‘VP’, [Tree(‘VT’, [‘plays’]), Tree(‘NP’, [‘baseball’])])</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree[1].node
‘VP’</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree[1,1]
Tree(‘NP’, [‘baseball’])</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree[1,1].node
‘NP’</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree[1,1,0]
‘baseball’</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree.leaves()
[‘Gary’, ‘plays’, ‘baseball’]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="grammar--chomsky-normal-form">3. Grammar , Chomsky normal form</h2>

<p>我們也可以看看這個tree是由哪些grammar產生的</p>

<p>可以用<code>productions()</code>得出grammar</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree.productions()
[S -&gt; NP VP, NP -&gt; ‘Gary’, VP -&gt; VT NP, VT -&gt; ‘plays’, NP -&gt; ‘baseball’]</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再來,我們可以把grammar轉成chomsky normal form(CNF)</p>

<p>（若不清楚CNF是什麼,請查閱”計算理論”的教科書)</p>

<p>首先,看看一個不符合CNF的例子:</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree2= Tree(‘S’, [ Tree(‘NP’, [‘Gary’]),
…                     Tree(‘VT’, [‘play’]), 
…                     Tree(‘NP’, [‘baeball’])])</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree2.productions()
[S -&gt; NP VT NP, NP -&gt; ‘Gary’, VT -&gt; ‘play’, NP -&gt; ‘baeball’]</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree2.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh3.googleusercontent.com/-RO644KujeOY/UyF3tRi2mfI/AAAAAAAAAXA/i1iPNbISnaA/w285-h189-no/nltk2.png" alt="nltk2.png" /></p>

<p><code>S -&gt; NP VT NP</code>不符合chomsky normal form</p>

<p>可以用<code>chomsky_normal_form()</code></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree2.chomsky_normal_form()
tree2.productions()
[S -&gt; NP S|<vt-np>, NP -&gt; 'Gary', S|<vt-np> -&gt; VT NP, VT -&gt; 'play', NP -&gt; 'baeball']</vt-np></vt-np></p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree2.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh5.googleusercontent.com/-aW-KwndtZOg/UyF3tQfi-jI/AAAAAAAAAXE/j4fpXq2-9Ro/w273-h234-no/nltk3.png" alt="nltk3.png" /></p>

<p>轉換後產生了一個新的node,<code>S|&lt;VT-NP&gt;</code>,這樣子就符合CNF了</p>

<h2 id="parse-tree-from-string">4.Parse tree from string</h2>

<p>如果我們現在有一個string如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>s=r”(S (NP Gary) (VP (VT plays) (NP baseball)))”</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>要從這個string建立出tree,可用以下方法：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tree3=Tree.parse(s)
tree3.pprint()
‘(S (NP Gary) (VP (VT plays) (NP baseball)))’</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="section">結語：</h2>

<p>想要看更多參考資料,請到：</p>

<p>tutorial:</p>

<p>https://nltk.googlecode.com/svn/trunk/doc/howto/tree.html</p>

<p>http://www.mit.edu/~6.863/spring2011/labs/nltk-tree-pages.pdf</p>

<p>api documentation:</p>

<p>http://nltk.googlecode.com/svn/trunk/doc/api/nltk.tree.Tree-class.html#productions</p>

<p>source code:</p>

<p>http://www.nltk.org/_modules/nltk/tree.html</p>
]]></content>
  </entry>
  
</feed>
