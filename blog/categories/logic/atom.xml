<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Logic | Mark Chang's Blog]]></title>
  <link href="http://ckmarkoh.github.io/blog/categories/logic/atom.xml" rel="self"/>
  <link href="http://ckmarkoh.github.io/"/>
  <updated>2016-12-11T11:18:48+08:00</updated>
  <id>http://ckmarkoh.github.io/</id>
  <author>
    <name><![CDATA[Mark Chang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[形式語意學 -- Davidsonian Event Semantics]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/04/04/formal-semantics-davidsonian-event-semantics/"/>
    <updated>2014-04-04T17:13:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/04/04/formal-semantics-davidsonian-event-semantics</id>
    <content type="html"><![CDATA[<h2 id="introduction">1.Introduction</h2>

<p>所謂的形式語義學( <em>Formal Semantics</em> ), 是在研究, 如何把自然語言用邏輯形式來表達</p>

<p>例如以下句子</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\text{John buttered the toast.} &(1.a)

\end{align}

 %]]&gt;</script>

<p>傳統上, 用一皆邏輯 <em>First Order Logic</em> 可以把這個句子表示成這樣</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&butter(John,toast) &(1.b)

\end{align}

 %]]&gt;</script>

<!--more-->

<p>其中, <em>butter</em> 這個邏輯式的predicate, 而 <em>John</em> 和 <em>toast</em> 分別是argument, 這個邏輯式表示了 <em>John</em> 和 <em>toast</em> 的關係, </p>

<p>當這句話為真的時候, </p>

<script type="math/tex; mode=display">

butter(John,toast) \equiv True

</script>

<p>如果現在句子是這樣, 有個介繫詞片語修飾, 例如：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\text{John butterd the toast with the knife} &(2.a) 

\end{align}

 %]]&gt;</script>

<p>則可以把 <script type="math/tex">(1.b)</script> 的一階邏輯式,再加入一個論元 (argument) 擴充成這樣</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&butter(John,toast,knife) &(2.b) 

\end{align}

 %]]&gt;</script>

<p>但這方法有個缺點, 就是無法推論 <script type="math/tex">(2.b)</script> 這個邏輯式是否蘊含 <script type="math/tex">(1.b)</script></p>

<script type="math/tex; mode=display">

butter(John,toast,knife) \nrightarrow butter(John,toast)

</script>

<p>而事實上, <script type="math/tex">(2.a)</script> 這句話蘊含 <script type="math/tex">(1.a)</script> , 是成立的</p>

<script type="math/tex; mode=display">

\text{John butterd the toast with the knife} \rightarrow \text{John buttered the toast.}

</script>

<p>照理說, 邏輯式要可以表達這些自然語言中的蘊含關係</p>

<p>因此就要想出一個邏輯表達方法, 也可以讓這些蘊含推論成立</p>

<h2 id="davidsonian-event-semantics">2.Davidsonian event semantics</h2>

<p><em>Davidson</em> 在 1969 年提出了 <em>event</em> 的概念 </p>

<blockquote>
  <p>what adverbial clauses modify is not verbs but the events that certain verbs introduce.
Davidson (1969/1980: 167)</p>
</blockquote>

<p>意思就是, 修飾動詞的修飾語, 其實是在修飾這個動詞引出的事件</p>

<p>例如, 針對句子 <script type="math/tex">(1.a)</script>  , 可以把動詞 <em>butter</em> 引出的事件定為 <script type="math/tex">e</script> , 並加到 <script type="math/tex">(1.b)</script> 中 <em>butter</em>的argument,如下：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\exists e  (butter(John,toast,e)) &(1.c)

\end{align}

 %]]&gt;</script>

<p>其中, 式子前面的 <script type="math/tex">\exists e</script> 表示, 當這個式子成立的時候, 存在 <script type="math/tex">e</script> 這樣一個事件</p>

<p>然後, 句子 <script type="math/tex">(2.a)</script> 的邏輯式也可以用 <em>event</em> 的概念擴充, 可以把修飾語 <em>with a knife</em> 替換成 <script type="math/tex">instr(e,knife)</script>,  表示執行這個 <em>event</em> 的 <em>instrument</em> 為 <em>knife</em> , 如下：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\exists e  (butter(John,toast,e)\wedge instr(e,knife)) &(2.c)

\end{align}

 %]]&gt;</script>

<p>來檢查一下邏輯式 <script type="math/tex">(2.c)</script> 是否蘊含 <script type="math/tex">(1.c)</script></p>

<script type="math/tex; mode=display">

\exists e  (butter(John,toast,e)\wedge instr(e,knife)) \rightarrow \exists e  (butter(John,toast,e))

</script>

<p>以上蘊含成立</p>

<p>除此之外, 一個動詞可能同時被很多個介繫詞片與修飾, 例如以下句子</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

\text{John buttered the toast in the bathroom with the knife at midnight} &(3.a)

\end{align}

 %]]&gt;</script>

<p><script type="math/tex">(3.a)</script> 不但蘊含 <script type="math/tex">(2.a)</script> 也蘊含 <script type="math/tex">(1.a)</script></p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\text{John buttered the toast in the bathroom with the knife at midnight} &(3.a) \\

&\rightarrow  

\text{John butterd the toast with the knife} &(2.a)  \\

&\rightarrow 

\text{John buttered the toast.} &(1.a) \\

\end{align}

 %]]&gt;</script>

<p>這種句子如果用沒有引入 <em>event</em> 的概念, 用 <script type="math/tex">(2.b)</script> 的傳統邏輯式子, 問題就更大了</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&butter(John,toast,knife,bathroom,midnight) &(3.b) 

\end{align}

 %]]&gt;</script>

<p>這樣的話, 我們就要定義 <em>butter</em> 可以接收很多個argument, 且要定好哪個位置是填給哪一種修飾語用的, 當然, <script type="math/tex">(3.b)</script> 蘊含 <script type="math/tex">(2.b)</script> 的推論也不成立</p>

<p>用 <em>event</em> 的概念就簡單很多了, 不用修改到 <em>butter</em> 的argument, 只要把修飾語轉換成修飾 <script type="math/tex">e</script> 的predicate, 並和 <em>butter</em> 做conjunction, 就可以了, 如下</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\exists e  (butter(John,toast,e)\wedge instr(e,knife) \wedge in(e,bathroom) \wedge at(e,midnight) ) &(3.c)

\end{align} 

 %]]&gt;</script>

<p>而且 <script type="math/tex">(3.c)</script> 蘊含 <script type="math/tex">(2.c)</script> 也蘊含 <script type="math/tex">(1.c)</script> </p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\exists e  (butter(John,toast,e)\wedge instr(e,knife) \wedge in(e,bathroom) \wedge at(e,midnight) ) &(3.c) \\

&\rightarrow \exists e  (butter(John,toast,e)\wedge instr(e,knife)) &(2.c) \\

&\rightarrow \exists e  (butter(John,toast,e)) &(1.c) \\

\end{align}

 %]]&gt;</script>

<h2 id="implementation">3.Implementation</h2>

<p>來載入模組, 實作看看</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk.sem.logic as logic
from nltk import Prover9
lgp = logic.LogicParser()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>用前面提到的句子和邏輯式子來做練習</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&\text{John buttered the toast.} &(1.a) \\

&\text{John butterd the toast with the knife} &(2.a)  \\

&\text{John buttered the toast in the bathroom with the knife at midnight} &(3.a) \\

\\

& \exists e  (butter(John,toast,e)) &(1.c) \\

& \exists e  (butter(John,toast,e)\wedge instr(e,knife)) &(2.c) \\

&\exists e  (butter(John,toast,e)\wedge instr(e,knife) \wedge in(e,bathroom) \wedge at(e,midnight) ) &(3.c) \\

\end{align}

 %]]&gt;</script>

<p>把 <script type="math/tex">(1.a)</script> , <script type="math/tex">(2.a)</script> , <script type="math/tex">(3.a)</script> , 這三句話的邏輯式  <script type="math/tex">(1.c)</script> , <script type="math/tex">(2.c)</script> , <script type="math/tex">(3.c)</script> 分別輸入到LogicParser, 如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>a1 = lgp.parse(‘exists e ( butter(John,toast,e))’)
a2 = lgp.parse(‘exists e ( butter(John,toast,e) &amp; instr(e,knife) )’)
a3 = lgp.parse(‘exists e (butter(John,toast,e) &amp; instr(e,knife) &amp; in (e,bathroom) &amp; at(e,midnight) )’)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著來看看句子 <script type="math/tex">(1.a)</script> 和 <script type="math/tex">(2.a)</script> 的蘊含關係</p>

<p>用 <code>Prover9()</code> 來證明, 我們把未知值的句子放在第一個argument ,  已知為真的句子放在第二個argument中</p>

<p>例如, 想要證明當  <script type="math/tex">(2.a)</script> 為真時, <script type="math/tex">(1.a)</script> 是否為真, 輸入方法如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Prover9().prove(a1, [a2])
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>結果顯示, 當 <script type="math/tex">(2.a)</script> 為真, <script type="math/tex">(1.a)</script> 必為真, 表示 <script type="math/tex">(2.a)</script>  蘊含 <script type="math/tex">(1.a)</script> </p>

<p>把 <script type="math/tex">(2.a)</script> 和 <script type="math/tex">(1.a)</script> 對調</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Prover9().prove(a2, [a1])
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>結果顯示, <script type="math/tex">(1.a)</script> 蘊含 <script type="math/tex">(2.a)</script> 不成立</p>

<p>然後來看看 <script type="math/tex">(3.a)</script> 和 <script type="math/tex">(2.a)</script> 以及 <script type="math/tex">(1.a)</script> 的蘊含關係</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Prover9().prove(a2, [a3])
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>Prover9().prove(a1, [a3])
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>結果顯示, <script type="math/tex">(3.a)</script> 蘊含 <script type="math/tex">(2.a)</script> 也蘊含 <script type="math/tex">(1.a)</script></p>

<h2 id="reference">4. Reference</h2>

<p>本文參考至以下這本語意學書籍</p>

<p><a href="http://www.amazon.com/Semantics-International-Handbooks-Linguistics-Communication/dp/3110184702">Semantics: An International Handbook of Natural Language Meaning</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Nltk -- Logic 4 : Model and Satisfiability]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/03/29/python-nltk-logic-4/"/>
    <updated>2014-03-29T15:39:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/03/29/python-nltk-logic-4</id>
    <content type="html"><![CDATA[<h2 id="model-and-satisfiability">1.Model and Satisfiability</h2>

<p>可滿足性(Satisfiability)是在探討, 邏輯式子所建立出的模型(Model),</p>

<p>可不可以找到一組解, 使得這個 <em>Model</em> 算出來的值可以是 <script type="math/tex">True</script></p>

<p>例如：</p>

<script type="math/tex; mode=display">

p1=(x \vee y), \mspace{5mu}

p2=(\neg x \vee y),  \mspace{5mu}

p3=(x \vee \neg y) \\

M1=p1 \wedge p2 \wedge p3

</script>

<p>則當 <script type="math/tex">x\equiv True, \mspace{5mu} y \equiv  True</script> 時, <script type="math/tex">M1 \equiv True </script></p>

<p>則 <em>Model</em> <script type="math/tex">M1</script> 是 <em>Satisfiable</em></p>

<p>另一例子：</p>

<script type="math/tex; mode=display">

p1=(x \vee y), \mspace{5mu}

p2=(\neg x \vee y),  \mspace{5mu}

p3=(x \vee \neg y) \mspace{5mu}

p4=(\neg x \vee \neg y)\\

M2=p1 \wedge p2 \wedge p3 \wedge p4

</script>

<p>這種情形,不論 <script type="math/tex">x</script> 或 <script type="math/tex">y</script> 的值,  <script type="math/tex">M2</script> 永遠都是 <script type="math/tex">False</script></p>

<p>則 <em>Model</em> <script type="math/tex">M2</script> 是 <em>Unsatisfiable</em></p>

<!--more-->

<h2 id="implementation-1">2.Implementation 1</h2>

<p>接著我們用nltk來做簡單的 <em>Satisfiability</em> 問題</p>

<p>先載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk
lgp = nltk.LogicParser()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著,輸入邏輯式子<script type="math/tex">p1=(x \vee y), \mspace{5mu} p2=(\neg x \vee y),  \mspace{5mu}p3=(x \vee \neg y) \mspace{5mu}</script></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <table>
        <tbody>
          <tr>
            <td>p1 = lgp.parse(‘x</td>
            <td>y’)</td>
          </tr>
          <tr>
            <td>p2 = lgp.parse(‘-x</td>
            <td>y’)</td>
          </tr>
          <tr>
            <td>p3 = lgp.parse(‘x</td>
            <td>-y’)</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>然後把assignment加進去, 看看 <script type="math/tex">M1=p1 \wedge p2 \wedge p3</script> 是否 <em>satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>val = nltk.Valuation([(‘x’, True), (‘y’, True)])
dom = val.domain
g = nltk.Assignment(dom)
m = nltk.Model(dom, val)
m.satisfy(p1 &amp; p2 &amp; p3, g ) 
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再把 <script type="math/tex">p4=(\neg x \vee \neg y)</script> 加進去, 看看<script type="math/tex">M2=p1 \wedge p2 \wedge p3 \wedge p4</script> 是否 <em>satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>p4 = lgp.parse(‘-x | -y’)
m.satisfy(p1 &amp; p2 &amp; p3 &amp; p4, g ) 
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="first-order-logic">3. First Order Logic</h2>

<p>接著我們來看看如何將 <em>Model</em> 和 <em>Satisfiability</em> 的概念, 推廣到一階邏輯(First Order Logic)中</p>

<p>例如,在某個世界裡,</p>

<p><em>Gary</em> 是個男生, <em>Judy</em> 是個女生, 而 <em>Henry</em> 是一隻狗,</p>

<p><em>Gary</em> 和 <em>Henry</em> 在跑步, </p>

<p><em>Judy</em> 看見 <em>Henry</em> 而 <em>Gary</em> 看見 <em>Judy</em></p>

<p>我們可以用一階邏輯(First Order Logic)把這個世界表示成一個 <em>Model</em>：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

&M=\\

& Gary(g)  &\wedge \mspace{15mu} & Judy(j)  &\wedge \mspace{15mu} &Henry(h) &\wedge\\

& Boy(g)   &\wedge \mspace{15mu} & Girl(j)  &\wedge \mspace{15mu} &Dog(h)   &\wedge\\

& Run(g)   &\wedge \mspace{15mu} & Run(h)   &\wedge \mspace{15mu} & & \\

& See(j,h) &\wedge \mspace{15mu} & See(g,j) &\wedge \mspace{15mu} &See(g,h)

\end{align}

 %]]&gt;</script>

<p>根據這個Model, 用<em>Satisfiability</em>的概念, 可以求解以下問題</p>

<p>1 . 找找看這個世界中女生有哪些</p>

<p>這個問題可以看成是, 從找 <em>M</em> 中找出滿足 <script type="math/tex">girl(x)</script> 的 <script type="math/tex">x</script> 值有哪些, </p>

<p>可求解 <script type="math/tex">girl(x) \wedge M </script> 的 <em>Satisfiability</em> , 得出：</p>

<p>女生有 <em>Judy</em> , 因為當 <script type="math/tex">x=j</script> 時, <script type="math/tex">girl(x) \wedge M </script> 為 <em>Satisfiable</em></p>

<p>2 . 回答這個世界中是否有男生在跑步, 或者, 是否有女生在跑步</p>

<p>這可以看成是, 判斷某個 formula 和這個 <em>M</em> 是否有交集, 得出：</p>

<p>有男生在跑步, 因為 <script type="math/tex">\exists x(Run(x) \wedge boy(x) ) </script> 在 <script type="math/tex"> M </script> 中為 <em>Satisfiable</em></p>

<p>沒有女生在跑步, 因為 <script type="math/tex">\exists x(Run(x) \wedge girl(x) ) </script> 在 <script type="math/tex"> M </script> 中為 <em>Unsatisfiable</em></p>

<p>3 . 回答是否 <em>Judy</em> 看見 <em>Henry</em> , 或者,是否 <em>Judy</em> 看見 <em>Gary</em></p>

<p>可以判斷某個assignment 是否可讓 <em>M</em> 為 <em>Satisfiable</em> , 得出：</p>

<p><em>Judy</em> 看見 <em>Henry</em> , 因為當 <script type="math/tex">x=j,y=h</script> 時, <script type="math/tex">See(x,y) </script> 在 <script type="math/tex">M </script> 中為 <em>Satisfiable</em></p>

<p><em>Judy</em> 沒有看見 <em>Gary</em> , 因為當<script type="math/tex">x=j,y=g</script> 時, <script type="math/tex">See(x,y) </script> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<p>註：</p>

<p>1.在 python nltk 用的是 <em>Closed World Assumption</em> </p>

<p>也就是說, 在 <em>Model</em> 裡面沒有定義的, 一律為 <em>False</em></p>

<p>例如沒有定義 <em>Run(j)</em> , 所以 <em>Run(j)</em> 為 <em>False</em> </p>

<p>因此 <script type="math/tex">\exists x(Run(x) \wedge girl(x) ) </script> 在 <script type="math/tex"> M </script> 中為 <em>Unsatisfiable</em> </p>

<p>同理, <em>See(j,g)</em> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<p>2.相對於 <em>Closed World Assumption</em> </p>

<p>有另一種叫作 <em>Open World Assumption</em> </p>

<p>是將沒有定義的formula 它視為 <em>Unknown</em></p>

<p>所以結果除了 <em>True</em> 和 <em>False</em> 之外, 還有 <em>Unknown</em></p>

<h2 id="implementation-2">4.Implementation 2</h2>

<p>用 python nltk 來實作看看：</p>

<p>首先, 建立 model</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>v = “”” 
… Gary =&gt; g
… Judy =&gt; j
… Henry =&gt; h
… boy =&gt; {g}
… girl =&gt; {j}
… dog =&gt; {h}
… run =&gt; {g, h}
… see =&gt; {(j, h), (g, j), (g, h)}
… “””</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>val = nltk.parse_valuation(v)
m = nltk.Model(val.domain, val)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>1.求 <script type="math/tex">girl(x)</script> 的 <script type="math/tex">x</script> 值:</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfiers(lgp.parse(‘girl(x)’), ‘x’  , nltk.Assignment(val.domain, []))
set([‘j’])</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>得出結果 <script type="math/tex">x=j</script></p>

<p>2.求 <script type="math/tex">\exists x (Run(x) \wedge boy(x)) </script> 或 <script type="math/tex">\exists x (Run(x) \wedge girl(x))</script> 這兩個formula在 <script type="math/tex">M</script> 中是否為 <em>Satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘exists x.(run(x) &amp; boy(x))’),nltk.Assignment(val.domain, []))
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘exists x.(run(x) &amp; girl(x))’),nltk.Assignment(val.domain, []))
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>得出結果：</p>

<p><script type="math/tex">\exists x(Run(x) \wedge boy(x) )</script> 在 <script type="math/tex">M </script> 中為 <em>Satisfiable</em></p>

<p><script type="math/tex">\exists x(Run(x) \wedge girl(x) ) </script> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<p>3.求 <script type="math/tex">x=j,y=h</script> 或 <script type="math/tex">x=j,y=g</script> 對於 <script type="math/tex">See(x,y)</script> 在 <script type="math/tex">M</script> 中是否為 <em>Satisfiable</em></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘see(x,y)’),nltk.Assignment(val.domain,[(‘x’, ‘j’), (‘y’, ‘h’)]))
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>m.satisfy(lgp.parse(‘see(x,y)’),nltk.Assignment(val.domain,[(‘x’, ‘j’), (‘y’, ‘g’)]))
False</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>得出結果：</p>

<p>當 <script type="math/tex">x=j,y=h</script> 時, <script type="math/tex">See(x,y) </script> 在 <script type="math/tex">M </script> 中為 <em>Satisfiable</em></p>

<p>當<script type="math/tex">x=j,y=g</script> 時, <script type="math/tex">See(x,y)</script> 在 <script type="math/tex">M </script> 中為 <em>Unsatisfiable</em></p>

<h2 id="reference">5.Reference</h2>

<p>關於python nltk的 <em>model</em> 和 <em>satistiability</em> 可參考：</p>

<p>http://nltk.googlecode.com/svn/trunk/doc/book/ch10.html</p>

<p>關於 <em>Closed World Assumption</em> 與 <em>Open World Assumption</em> 可參考：</p>

<p>http://en.wikipedia.org/wiki/Closed_world_assumption</p>

<p>http://en.wikipedia.org/wiki/Open_world_assumption</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Nltk -- Logic 3 : Discourse Representation Theory]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/03/21/python-nltk-logic-3/"/>
    <updated>2014-03-21T03:58:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/03/21/python-nltk-logic-3</id>
    <content type="html"><![CDATA[<h2 id="introduction">1. Introduction</h2>

<p><em>Discourse</em> 的意思是對話</p>

<p>在對話中,常常會用到 <strong>代名詞</strong> ,像是 <em>he</em>, <em>she</em> 或 <em>it</em>.</p>

<p>我們把這種代名詞叫做 <em>anaphoric pronouns</em></p>

<p>因為要從前面的句子去判斷,這些代名詞代表什麼</p>

<p>比如有個句子 <em>A woman walks. She smokes.</em></p>

<p>在下一句的 <em>She</em> 是指前一句提到的 <em>A woman</em></p>

<p>那要怎麼讓電腦去判斷, <strong>代名詞</strong> 到底代表前面提到的什麼？</p>

<p>這就要用到 <em>Discourse Representation Theory (DRT)</em> 來處理了</p>

<p>例如 <em>A woman walks</em> 這句話,用 <em>DRT</em> 可以表示成這樣：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline x  \\ \hline

    	woman(x) \\

      walk(x) \\

    \hline

		\end{array}

</script>

<!--more-->

<p>這樣一個框框的結構叫作 <em>Discourse Representation Structure</em> ,簡稱 <em>DRS</em></p>

<p>其中位於方框上面的 <script type="math/tex">x</script> 叫做 <em>Discourse Referent</em> </p>

<p>它代表這個句子中,可以被其他代名詞參考的東西</p>

<p>方框下方的式子叫做 <em>DRS conditions</em> </p>

<p>它代表這些文句所產生的情境</p>

<p>第二個句子 <em>She smokes.</em></p>

<p>用 <em>DRT</em> 表示成這樣：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline y  \\ \hline

      PRO(y) \\

      smoke(y) \\

    \hline

		\end{array}

</script>

<p>其中, <script type="math/tex">PRO(y)</script> 表示 <script type="math/tex">y</script> 是一個代名詞,但不知道它代表誰</p>

<p>這個時候就要用 <em>DRT</em> ,把對話中前後語句的情境結合起來</p>

<p>就可以進行 <em>Resolve Anaphora</em> 找出代名詞代表什麼</p>

<p>例如：</p>

<p><em>A woman walks. She smokes.</em></p>

<p>用 <em>DRT</em> 表示成：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline x  \\ \hline

    	woman(x) \\

      walk(x) \\

    \hline

		\end{array}

    +

    \begin{array}{|c|}

    \hline y  \\ \hline

      PRO(y) \\

      smoke(y) \\

    \hline

		\end{array}

    \xrightarrow{Simplify}

    \begin{array}{|c|}

    \hline x,y  \\ \hline

    	woman(x) \\

      walk(x) \\

      PRO(y) \\

      smoke(y) \\

    \hline

		\end{array}

    \xrightarrow{Resolve\mspace{5mu} Anaphora}

    \begin{array}{|c|}

    \hline x,y  \\ \hline

    	woman(x) \\

      walk(x) \\

      x = y \\

      smoke(y) \\

    \hline

		\end{array}

</script>

<p>藉由 <em>DRT</em> ,我們可以知道 <em>She</em> 是指 <em>A woman</em></p>

<p>然後,還可以把 <em>DRS</em> 轉成一階邏輯的式子：</p>

<p>像這樣：</p>

<script type="math/tex; mode=display">

    \begin{array}{|c|}

    \hline x,y  \\ \hline

    	woman(x) \\

      walk(x) \\

      x = y \\

      smoke(y) \\

    \hline

		\end{array}

    \Rightarrow

    \exists x \exists y.( woman(x) \wedge walk(x) \wedge (x = y) \wedge smoke(y))

</script>

<h2 id="drt-in-nltk">2. DRT in nltk</h2>

<p>現在我們來用nltk實作看看</p>

<p>先載入模組</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>接著我們輸入 <em>A woman walks</em> 的 <em>DRT</em> </p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>dp = nltk.DrtParser()
drs1 = dp.parse(‘([x], [woman(x), walk(x)])’) 
print drs1
([x],[woman(x), walk(x)])</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>我們也可以把 <em>DRT</em> 的結構畫出來</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs1.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>像這樣</p>

<p><img src="http://lh6.googleusercontent.com/-89PLq9VYopQ/UyvQx-TxTfI/AAAAAAAAAqY/cU232E7UWKQ/s165-no/DRT.png" /></p>

<p>接著我們把第二句話 <em>She smokes.</em> 也一起輸入</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs2 = dp.parse(‘([y], [PRO(y),smokes(y)])’) 
drs2.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh3.googleusercontent.com/-ugJ-AhsCo28/Uyva__Uz4QI/AAAAAAAAAqw/wgYKB9yYOcI/w163-h165-no/DRT2.png" /></p>

<p>其中 <code>PRO(y)</code> 是未知的代名詞,</p>

<p>因為只看這句話不知道這個代名詞代表什麼, </p>

<p>需要和第一句話結合起來才知道</p>

<p>我們可以用 <code>+</code> 把這 <em>兩個DRS</em> 合起來</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs3=drs1+drs2
drs3.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh6.googleusercontent.com/-ZVVEazh0bxU/Uyva_xl9HZI/AAAAAAAAArE/FOh2NjrkihE/w335-h158-no/DRT3.png" /></p>

<p>再用 <code>simplify()</code> 把這兩個 <em>DRS</em> 簡化成一個</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs4=drs3.simplify()
drs4.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh6.googleusercontent.com/-XS97Rkd11iM/Uyva_tAb7oI/AAAAAAAAArU/ga7l4KP5QV4/w165-h240-no/DRT4.png" /></p>

<p>然後再用 <code>resolve_anaphora()</code> 找出代名詞 <code>PRO(y)</code> 代表什麼</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>drs5=drs4.resolve_anaphora()
drs5.draw()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p><img src="http://lh6.googleusercontent.com/-xqOOLlm0h7w/UyvbAKBA7RI/AAAAAAAAAq8/KOkSJP2nJG4/w168-h240-no/DRT5.png" /></p>

<p>這時,原本的 <code>PRO(y)</code>  會變成 <code>(y = x)</code> 表示已經找出了 <code>y</code> 代表什麼</p>

<p>然後, 還可以把 <em>DRS</em> 轉成 <em>First-order Logic</em> 的式子</p>

<p>像這樣：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>f1=drs5.fol()
print f1
exists x y.(woman(x) &amp; walks(x) &amp; (y = x) &amp; smokes(y))</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>這樣就大功告成了</p>

<h2 id="further-reading">3.Further Reading</h2>

<p>其實 <em>DRT</em> 還可以解決許多關於對話中的語意問題</p>

<p>有興趣的話可以看這個網站：Discourse Representation Theory </p>

<p>http://www.coli.uni-saarland.de/projects/milca/courses/comsem/html/node205.html</p>

<p>以及這本書：</p>

<p><em>Hans Kamp, Josef van Genabith, Uwe Reyle. Discourse Representation Theory</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Nltk -- Logic 2 : Lambda Calculus]]></title>
    <link href="http://ckmarkoh.github.io/blog/2014/03/13/python-nltk-logic-2/"/>
    <updated>2014-03-13T14:09:00+08:00</updated>
    <id>http://ckmarkoh.github.io/blog/2014/03/13/python-nltk-logic-2</id>
    <content type="html"><![CDATA[<p>本篇介紹如何用python nltk 的應用,邏輯語意與lambda calculus</p>

<h2 id="introduction">1.introduction</h2>

<p>邏輯語意學在語意推導方面,通常會用到 <script type="math/tex">\lambda -calculus</script></p>

<p>使用<script type="math/tex">\lambda -calculus</script>就可以把一個句子的語意,從個別單字中推導出來</p>

<p>至於<script type="math/tex">\lambda -calculus</script> 是什麼呢？</p>

<p>簡而言之,lambda calculus是一種數學運算,由以下三種元素組成</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}


& v  & (a)\\

& \lambda x.f(x)  & (b)\\

& \lambda x.f(x)(v) & (c)\\


\end{align}

 %]]&gt;</script>

<p><script type="math/tex">(a)</script> 是 <script type="math/tex">variable</script></p>

<p><script type="math/tex">(b)</script> 是 <script type="math/tex">astraction</script> ,就是把function中的variable拿到前面,加個 <script type="math/tex">\lambda</script></p>

<p><script type="math/tex">(c)</script> 是將另一個 <script type="math/tex">variable</script> 放到 <script type="math/tex">astraction</script> 後面</p>

<p>然後可以進行一種運算,叫做 <script type="math/tex">\beta-reduction</script> ,如下</p>

<script type="math/tex; mode=display">

\lambda x.f(x)(v)

\Rightarrow f(v)

</script>

<p>還有另一種運算叫做 <script type="math/tex">\alpha-conversion</script> ,其實就是更改變數名稱而已</p>

<script type="math/tex; mode=display">

\lambda x.f(x)

\Rightarrow \lambda y.f(y)

</script>

<!--more-->

<p><script type="math/tex">\lambda -calculus</script> 也是計算理論的一種,和Turing Machine等價</p>

<p>實際上以 <script type="math/tex">\lambda -calculus</script> 實現的程式語言有Functional Programming,例如Lisp或Haskell</p>

<h2 id="lambda-expression">2. lambda expression</h2>

<p>接著來實作untyped lambda calculus,</p>

<p>首先,載入模組 <code>nltk.sem.logic</code> 和 <code>LogicParser</code></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>import nltk.sem.logic as logic
lgp = logic.LogicParser()</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再看看 <script type="math/tex">\lambda</script> 要用哪個符號</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>logic.binding_ops()
existential    	exists
universal      	all
lambda         	\</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>要表示lambda <script type="math/tex">\lambda</script> 符號,要用 <code>\</code> 字串</p>

<p>然後,用<code>LogicParser</code>來輸入這個式子：<script type="math/tex">e1=\lambda x.P(x)</script></p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e1 = lgp.parse(r’\x.P(x)’)
print e1
\x.P(x)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="alpha-conversion">3. alpha conversion</h2>

<p>再來試試看<script type="math/tex">\alpha-conversion</script> : <script type="math/tex">\exists x.P(x) \Rightarrow \exists z.P(z)</script></p>

<p>從以下結果得知,<script type="math/tex">\alpha-conversion</script> 轉換前和轉換後,在邏輯上是相等</p>

<p>因為只是更改變數名稱而已</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e2 = e1.alpha_convert(logic.Variable(‘z’))
print e2
\z.P(z)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e1 == e2
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="beta-reduction">4. beta reduction</h2>

<p>接著,來看看 <script type="math/tex">\beta-reduction</script> </p>

<p>舉一個自然語言的例子,例如 <em>Gary walks.</em> 這個句子,用邏輯語意可以表示成</p>

<script type="math/tex; mode=display">

walks(Gary)

</script>

<p>根據Principle of Compositionality,</p>

<p>句子的語意是由單字的語意所組成的(但實際上還是有例外,例如片語)</p>

<p>推導出這個句子的語意,可由單字的語意推導出來,</p>

<p><em>walks</em> 的語意是 <script type="math/tex">\lambda x.walk(x)</script></p>

<p><em>Gary</em> 的語意是 <script type="math/tex">Gary</script></p>

<p>則 <em>Gary walks</em> 的語意是</p>

<script type="math/tex; mode=display">

\lambda x.walks(x) (Gary)\Rightarrow walks(Gary)

</script>

<p>接著來實作看看</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e3 = lgp.parse(r’\x.walks(x)(Gary)’)
e4 = e3.simplify()
print e4
walks(Gary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>再舉一個例子,例如 <em>Gary sees Mary.</em> 這個句子, <em>sees</em> 是及物動詞</p>

<p>及物動詞,是表示一個主詞和受詞的關係,</p>

<p>可用 <em>First Order Logic</em> 的 <em>Relation</em> 來表示</p>

<p><em>sees</em> 的語意為 <script type="math/tex">\lambda x \lambda y .see(x,y)</script></p>

<p>而 <em>Gary sees Mary.</em> 的語意是</p>

<script type="math/tex; mode=display">% &lt;![CDATA[


\begin{align}

& \lambda x \lambda y.see(x,y) (Gary) (Mary) \\

& \Rightarrow \lambda y(Gary,y) (Mary) \\

& \Rightarrow see(Gary,Mary)

\end{align}

 %]]&gt;</script>

<p>接著,輸入nltk看看</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e5 = lgp.parse(r’\x \y.see(x,y)(Gary)(Mary)’)
print e5
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e5.simplify()
see(Gary,Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>還有其他的輸入方式,結果都一樣</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e6 = lgp.parse(r’\x \y.see(x,y)(Gary,Mary)’)
e7 = lgp.parse(r’\x y.see(x,y)(Gary,Mary)’)
e8 = lgp.parse(r’\x y.see(x,y)(Gary)(Mary)’)
e9 = lgp.parse(r’(\x y.see(x,y)(Gary))(Mary)’)</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<p>結果如下：</p>

<p>```python</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e6
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e7
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e8
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>print e9
((\x y.see(x,y))(Gary))(Mary)</p>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>e6 == e7 == e8 == e5
True</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>```</p>

<h2 id="further-reading">5.further reading</h2>

<p>想要瞭解 <script type="math/tex">\lambda -calculus</script>, 請參考http://en.wikipedia.org/wiki/Lambda_calculus</p>

<p>想要看看 nltk 裡面的 <script type="math/tex">\lambda -calculus</script> , 請至http://www.nltk.org/howto/logic.html</p>

<p>還有關於邏輯語意的研究,可以參考這本書 <em>Blackburn &amp; Bos’  Representation and Inference for Natural Language</em></p>
]]></content>
  </entry>
  
</feed>
